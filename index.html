<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Lung Nodule Management</title>
<style>
html,body{font:16px/1.45 -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:#fafafa;color:#111}
.wrap{max-width:1080px;margin:20px auto;padding:0 14px}
h1{font-size:1.55rem;margin:.2rem 0 .8rem}
h2{font-size:1.1rem;margin:1.2rem 0 .4rem}
.card{background:#fff;border-radius:12px;box-shadow:0 1px 2px rgba(0,0,0,.06);padding:14px}
.grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));grid-gap:12px}
label{display:block;margin:.3rem 0 .15rem;font-weight:600}
select,input[type="number"],input[type="text"]{width:100%;padding:.55rem .6rem;border:1px solid #dcdcdc;border-radius:10px;background:#fff}
.row{margin:.4rem 0}
.muted{color:#666;font-size:.9rem}
.out{white-space:pre-wrap;background:#0b1520;color:#d9f1ff;padding:1rem;border-radius:12px;font-family:ui-monospace,SFMono-Regular,Consolas,monospace}
button{border:0;background:#0d5bd7;color:#fff;padding:.7rem 1rem;border-radius:10px;font-weight:700;cursor:pointer}
button.secondary{background:#f0f3f8;color:#0d1b2a}
.inline{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
.footer{font-size:.85rem;color:#555;margin-top:10px}
details{background:#f6f8fb;border-radius:10px;padding:.6rem .8rem;border:1px solid #e5eaf1}
summary{cursor:pointer;font-weight:600}
a{color:#0d5bd7}
.tabbar{display:flex;gap:8px;margin-bottom:10px;flex-wrap:wrap}
.tabbar button{background:#e9eef6;color:#102a43;border-radius:999px;padding:.5rem .9rem;border:1px solid #dbe4f0}
.tabbar button.active{background:#0d5bd7;color:#fff;border-color:#0d5bd7}
.section{display:none}
.section.active{display:block}
#errbar{position:fixed;left:10px;bottom:10px;z-index:9999;max-width:90%;display:none;background:#ffe8e8;color:#610404;border:1px solid #f5b5b5;border-radius:8px;padding:8px 10px;font:13px/1.4 system-ui}
.nodule-box {background:#eaf4ff;border-radius:10px;padding:10px;margin-top:8px;}
.modebox{border:1px solid #e5eaf1;border-radius:10px;padding:10px;margin-top:8px}

.chip-group{display:flex;gap:8px;flex-wrap:wrap;margin:.25rem 0 .35rem}
.chip{padding:.4rem .75rem;
  border:1px solid #a0a7b5;
  border-radius:999px;
  background:#f4f7fb;
  color:#333;
  cursor:pointer;
  user-select:none}
.chip.active{background:#0d5bd7;color:#fff;border-color:#0d5bd7}
.chip:hover:not(.active){background:#e2e7f2}
.chip:focus{outline:2px solid #9ec3ff;outline-offset:2px}
.chip-muted{opacity:.85}
.hidden-select{position:absolute;left:-9999px;top:-9999px;width:1px;height:1px;opacity:0}
.small-muted{color:#666;font-size:.9rem}

.badge-cat1{
  display:inline-block;
  padding:.15rem .45rem;
  border-radius:.5rem;
  background:#e6fff2;
  color:#0a7a3b;
  border:1px solid #b9efcf;
  font-weight:600;
}
.radio-group { display:flex; gap: 1rem; margin-top: 0.25rem; flex-wrap: wrap; }
.radio-group label { font-weight: 500; cursor: pointer; }
.risk-box { background: #ffecec; border-radius: 10px; padding: 8px; margin-top: 6px; }
.lr-find-box { background: #fff0f0; border-radius: 10px; padding: 8px; margin-top: 6px; }
.sep{border-top:1px solid #e5e7eb;margin:8px 0}
.row + .row{border-top:1px solid #eef2f7;padding-top:6px;margin-top:6px}

/* White background behind "Exam situation" input area in Lung-RADS mode */
#lungrads .row.exam-situation {
  background-color: #ffffff;
  border-radius: 8px;
  padding: 10px 12px;
  margin-bottom: 10px;
  box-shadow: 0 0 0 1px rgba(0,0,0,0.08);
}


/* Subtle widen for the Solid→Behavior 'Slow growth' chip */
#lr_behavior_solid_chips .chip[data-val="slow_multi"] {
  min-width: 8.5ch;
  text-align: center;
  padding: 0.45rem 0.9rem;
}


/* Fleischner right-column: light blue panel with thin inner rectangles like Lung-RADS */
#fleischner .grid > div:last-child,
#fleischner .lrlike-panel {
  background: #f5f9ff;
  border-radius: 8px;
  padding: 14px;
}
#fleischner .lrlike-panel .row {
  background: #ffffff;
  border: 1px solid rgba(0,0,0,0.08);
  border-radius: 8px;
  padding: 10px 12px;
  margin-bottom: 10px;
}
#fleischner .lrlike-panel h2 {
  /* keep the title outside the thin rectangle look */
  margin-top: 0;
  margin-bottom: 8px;
}


/* Fleischner right-column light-blue panel with thin inner rectangles (match Lung-RADS right column) */
#fleischner .nodule-box {
  background: #f5f9ff;
  border-radius: 8px;
  padding: 14px;
}
#fleischner .nodule-box .row {
  background: #ffffff;
  border: 1px solid rgba(0,0,0,0.08);
  border-radius: 8px;
  padding: 10px 12px;
  margin-bottom: 10px;
}
#fleischner .nodule-box h2 {
  margin-top: 0;
  margin-bottom: 8px; /* keep title outside the thin rectangles */
}


/* Light blue background for Fleischner Nodule section boxes */
#fleischner .nodule-box .row {
  background: #f0f8ff;
}


/* Match Lung-RADS left-column styling for Fleischner left column */
#fleischner .grid > div:first-child .row {
  background-color: #ffffff;
  border-radius: 8px;
  padding: 10px 12px;
  margin-bottom: 10px;
  box-shadow: 0 0 0 1px rgba(0,0,0,0.08);
}


/* Add pink accent to Risk level block to match Lung-RADS find box */
#fleischner .risk-box {
  background-color: #ffeef2;
  border-radius: 8px;
  padding: 10px 12px;
  box-shadow: 0 0 0 1px rgba(0,0,0,0.08);
}


/* Pink accent for Fleischner "Risk level" row (uses :has to target the row containing #fl_risk) */
#fleischner .grid > div:first-child .row:has(#fl_risk) {
  background-color: #ffeef2;
  border-radius: 8px;
  padding: 10px 12px;
  box-shadow: 0 0 0 1px rgba(0,0,0,0.08);
}


/* Lighter pastel red background for Risk level box */
#fleischner .risk-level-box, 
#fleischner .risk-level, 
#fleischner .risk-box {
  background: #fff8f8 !important;
  border: 1px solid #e6bfbf !important;
}


/* Enforce lighter pastel red for Risk level box */
#fleischner .risk-box { background: #fff8f8 !important; border: 1px solid #e6bfbf !important; }

</style>

<style>
#fl_risk_chips .chip.active {
  background-color: #c0392b !important; /* red */
  color: white !important;
  border-color: #a93226 !important;
}
.sep{border-top:1px solid #e5e7eb;margin:8px 0}
.row + .row{border-top:1px solid #eef2f7;padding-top:6px;margin-top:6px}
</style>

<style>#errbar{display:none !important;}</style>

<style>
/* Light gray background for 'Additional suspicious features' input area */
.lr-additional-box {
  background-color: #f5f5f5;
  padding: 10px 12px;
  border-radius: 6px;
}
</style>


<style>
/* Soft light-blue panel behind the entire right column of Lung-RADS detail inputs */
#lungrads .grid > div:last-child {
  background: #f5f9ff;
  border-radius: 8px;
  padding: 14px;
}
/* Ensure inner rows don't get extra background nesting effects */
#lungrads .grid > div:last-child .row {
  background: transparent;
}
</style>

<style>
/* Force lighter pastel red for Risk level box (high specificity & Safari-friendly) */
#fleischner .grid > div:first-child .row:has(#fl_risk) {
  background-color: #fffafa !important; /* barely pink */
  border: 1px solid #e6bfbf !important;
}
#fleischner .risk-box {
  background-color: #fffafa !important;
  border: 1px solid #e6bfbf !important;
}
</style>
<style>
/* Slightly redder tint and lighter outline for Risk level box */
#fleischner .grid > div:first-child .row:has(#fl_risk),
#fleischner .risk-box {
  background-color: #fff3f3 !important; /* a touch more red */
  border: 1px solid #f4dede !important; /* lighter outline */
}
</style>

<style>
/* Hide Fleischner action buttons */
#fleischner button#fl_compute,
#fleischner button#fl_reset {
  display: none !important;
}
</style>

</head>
<body>
<div id="errbar"></div>
<div class="wrap">
  <h1>Lung Nodule Management</h1>
  <div class="tabbar">
    <button class="active" data-tab="fleischner">Fleischner (Incidental)</button>
    <button data-tab="lungrads">Lung-RADS (Screening)</button>
  </div>

  <!-- FLEISCHNER SECTION -->
  <section id="fleischner" class="section active">
    <div class="card" style="margin-bottom:12px">
      <div class="grid">
<div>
          <h2>Patient / Context</h2>
          <div class="row">
            

<label>Immunocompetent &amp; no known cancer?</label>
<div class="radio-group">
  <label><input type="radio" name="fl_isEligible_radio" value="yes" checked> Yes</label>
  <label><input type="radio" name="fl_isEligible_radio" value="no"> No</label>
</div>
<select id="fl_isEligible" style="position:absolute;left:-9999px;width:1px;height:1px;opacity:0">
  <option value="yes" selected>Yes</option>
  <option value="no">No</option>
</select>

          </div>
          <div class="row">
            
<label>Age</label>
<div class="radio-group">
  <label><input type="radio" name="fl_agegrp_radio" value="lt35"> &lt;35 years old</label>
  <label><input type="radio" name="fl_agegrp_radio" value="ge35" checked> ≥35 years old</label>
</div>
<select id="fl_agegrp" style="position:absolute;left:-9999px;width:1px;height:1px;opacity:0">
  <option value="lt35">&lt;35 years old</option>
  <option value="ge35" selected>≥35 years old</option>
</select>

          </div>
          
<div class="row">
  <label>Risk level</label>
  <div class="chip-group" id="fl_risk_chips" data-value="low">
    <button type="button" class="chip active" data-val="low">Low</button>
    <button type="button" class="chip" data-val="high">High</button>
  </div>
  <!-- Hidden select kept for logic compatibility -->
  <select id="fl_risk" class="hidden-select">
    <option value="low" selected>Low</option>
    <option value="high">High</option>
  </select>
</div>

        </div>

        <div class="nodule-box">
          <h2>Nodule</h2>
          
<div class="row">
  <label>Single vs multiple nodules</label>
  <div class="chip-group" id="fl_multiplicity_chips" data-value="single">
    <button type="button" class="chip active" data-val="single">Single</button>
    <button type="button" class="chip" data-val="multiple">Multiple</button>
  </div>
  <select id="fl_multiplicity" class="hidden-select">
    <option value="single" selected>Single</option>
    <option value="multiple">Multiple</option>
  </select>
</div>

          
<div class="row">
  <label>Type</label>
  <div class="chip-group" id="fl_type_chips" data-value="solid">
    <button type="button" class="chip active" data-val="solid">Solid</button>
    <button type="button" class="chip" data-val="partsolid">Part‑solid</button>
    <button type="button" class="chip" data-val="nonsolid">Pure ground‑glass</button>
  </div>
  <!-- Keep hidden select for existing logic -->
  <select id="fl_type" class="hidden-select">
    <option value="solid" selected>Solid</option>
    <option value="partsolid">Part‑solid</option>
    <option value="nonsolid">Pure ground‑glass</option>
  </select>
</div>

          
<div class="row">
  <label>Total mean diameter</label>
  <div class="chip-group" id="fl_sizecat_chips" data-value="6to8">
    <button type="button" class="chip" data-val="lt6">&lt;6 mm</button>
    <button type="button" class="chip active" data-val="6to8">6–8 mm</button>
    <button type="button" class="chip" data-val="gt8">&gt;8 mm</button>
  </div>
  <!-- Keep hidden select for logic -->
  <select id="fl_sizecat" class="hidden-select">
    <option value="lt6">&lt;6 mm</option>
    <option value="6to8" selected>6–8 mm</option>
    <option value="gt8">&gt;8 mm</option>
  </select>
</div>

          
<div class="row" id="fl_solidCompRow">
  <label>Solid component — for part‑solid</label>
  <div class="chip-group" id="fl_sccat_chips" data-value="lt6">
    <button type="button" class="chip active" data-val="lt6">&lt;6 mm</button>
    <button type="button" class="chip" data-val="ge6">≥6 mm</button>
  </div>
  <!-- Keep hidden select for logic -->
  <select id="fl_sccat" class="hidden-select">
    <option value="lt6" selected>&lt;6 mm</option>
    <option value="ge6">≥6 mm</option>
  </select>
</div>

        </div>
      </div>
      <div class="inline" style="margin-top:10px">
        <button id="fl_compute">Compute recommendation</button>
        <button class="secondary" id="fl_reset">Reset</button>
        <div class="muted"></div>
      </div>
    </div>

    <div class="card">
      <h2>Result</h2>
      <div id="fl_result" class="out">Fill inputs and click “Compute recommendation”.</div>
      <div id="fl_notes" class="footer"></div>
    </div>

    
  </section>

  <!-- LUNG-RADS SECTION -->
  <section id="lungrads" class="section">
    <div class="card" style="margin-bottom:12px">
      <div class="grid">
        <div>
          <h2>Context</h2>
          <div class="row exam-situation">
            <label>Exam situation</label>
            <select id="lr_examSituation">
              <option value="routine">Routine screening interpretation</option>
              <option value="awaiting_prior">Prior chest CT being located for comparison</option>
              <option value="suspected_infectious">Findings suggestive of infectious/inflammatory process</option>
            </select>
          </div>
<div class="row lr-find-box">
            <label>Select finding type</label>
            <select id="lr_mode" onchange="try{showMode(); if(this.value==='partsolid') togglePartSolidSC();}catch(e){}">
              <option value="solid" selected>Solid nodule</option>
              <option value="partsolid">Part solid nodule</option>
              <option value="nonsolid">Non solid nodule (GGN)</option>
              <option value="juxta">Juxtapleural nodule</option>
              <option value="airway">Airway nodule</option>
              <option value="cyst">Atypical pulmonary cyst</option>
              <option value="benign">Nodule with benign features</option>
              <option value="none">No nodule</option>
            </select>
          </div>

          <div class="row lr-additional-box">
<label>Additional suspicious features</label>
            <select id="lr_extraSuspicious">
              <option value="none" selected>None</option>
              <option value="spiculation">Spiculation</option>
              <option value="lad">Lymphadenopathy</option>
              <option value="mets">Frank metastatic disease</option>
              <option value="ggn_double">GGN doubles in size in 1 year</option>
            </select>
            

          </div>
        </div>

        <div>
          <h2><span id="lr_find_heading">Finding type</span></h2>
          

          <!-- Mode containers -->
          <div id="mode_solid" class="modebox">
            <div class="row">
              <label>Behavior on current exam</label>
              
  <div class="chip-group" id="lr_behavior_solid_chips" data-select="lr_behavior_solid" data-value="baseline">
    <button type="button" class="chip" data-val="baseline">Baseline</button>
    <button type="button" class="chip" data-val="new">New</button>
    <button type="button" class="chip" data-val="growing">Growing</button>
    <button type="button" class="chip" data-val="slow_multi">Slow growth</button>
  </div>
  
  <div class="small-muted" style="margin-top:4px;">“Growing” = average diameter has increased by ≥1.5 mm. “Slow growth” = average diameter has increased over multiple exams but &lt;1.5 mm per 12 months.</div>
<select id="lr_behavior_solid" class="hidden-select">
                <option value="baseline" selected>Baseline</option>
                <option value="new">New</option>
                <option value="growing">Growing</option>
                <option value="slow_multi">Slow growth</option>
              </select>
</div>
            <div class="row">
  <label>Total mean diameter</label>

  <div class="chip-group size-chip-group" id="lr_size_solid_chips" data-select="lr_size_solid_cat" data-value="6to7_9">
    <button type="button" class="chip" data-val="lt4">&lt;4.0 mm</button><button type="button" class="chip" data-val="4to5_9">4.0 to 5.9 mm</button><button type="button" class="chip" data-val="6to7_9">6.0 to 7.9 mm</button><button type="button" class="chip" data-val="8to9_9">8.0 to 9.9 mm</button><button type="button" class="chip" data-val="10to14_9">10.0 to 14.9 mm</button><button type="button" class="chip" data-val="15to29_9">15.0 to 29.9 mm</button><button type="button" class="chip" data-val="ge30">&ge;30.0 mm</button>
  </div>
  <select id="lr_size_solid_cat" class="hidden-select">
    
  <option value="lt4">&lt;4.0 mm</option>
  <option value="4to5_9">4.0 to 5.9 mm</option>
  <option value="6to7_9" selected>6.0 to 7.9 mm</option>
  <option value="8to9_9">8.0 to 9.9 mm</option>
  <option value="10to14_9">10.0 to 14.9 mm</option>
  <option value="15to29_9">15.0 to 29.9 mm</option>
  <option value="ge30">&ge;30.0 mm</option>

  </select>

</div>
          </div>

          <div id="mode_partsolid" class="modebox" style="display:none">
            <div class="row">
  <label>Behavior on current exam</label>

  <div class="chip-group" id="lr_behavior_part_chips" data-select="lr_behavior_part" data-value="baseline">
    <button type="button" class="chip" data-val="baseline">Baseline</button><button type="button" class="chip" data-val="new_nodule">New nodule</button><button type="button" class="chip" data-val="new_solid">New or growing solid component in existing nodule</button>
  </div>
  <select id="lr_behavior_part" class="hidden-select">
    
        <option value="baseline" selected>Baseline</option>
        <option value="new_nodule">New nodule</option>
        <option value="new_solid">New or growing solid component in existing nodule</option>
      
  </select>

</div>
            <div class="row">
  <label>Total mean diameter</label>

  <div class="chip-group size-chip-group" id="lr_size_ps_chips" data-select="lr_size_part_cat" data-value="6to7_9">
    <button type="button" class="chip" data-val="lt4">&lt;4.0 mm</button><button type="button" class="chip" data-val="4to5_9">4.0 to 5.9 mm</button><button type="button" class="chip" data-val="6to7_9">6.0 to 7.9 mm</button><button type="button" class="chip" data-val="8to9_9">8.0 to 9.9 mm</button><button type="button" class="chip" data-val="10to14_9">10.0 to 14.9 mm</button><button type="button" class="chip" data-val="15to29_9">15.0 to 29.9 mm</button><button type="button" class="chip" data-val="ge30">&ge;30.0 mm</button>
  </div>
  <select id="lr_size_part_cat" class="hidden-select">
    
  <option value="lt4">&lt;4.0 mm</option>
  <option value="4to5_9">4.0 to 5.9 mm</option>
  <option value="6to7_9" selected>6.0 to 7.9 mm</option>
  <option value="8to9_9">8.0 to 9.9 mm</option>
  <option value="10to14_9">10.0 to 14.9 mm</option>
  <option value="15to29_9">15.0 to 29.9 mm</option>
  <option value="ge30">&ge;30.0 mm</option>

  </select>

</div>
            <div class="row" id="lr_solidCompRow_part">
              <label>Solid component</label>
              
  <div class="chip-group" id="lr_sc_part_chips" data-select="lr_solidComp_part_cat" data-value="lt4">
    <button type="button" class="chip" data-val="lt4">0.1 to 3.9 mm</button><button type="button" class="chip" data-val="4to5_9">4.0 to 5.9 mm</button><button type="button" class="chip" data-val="6to7_9">6.0 to 7.9 mm</button><button type="button" class="chip" data-val="ge8">&ge;8.0 mm</button>
  </div>
  <!-- Keep the original select hidden for logic compatibility -->
  <select id="lr_solidComp_part_cat" class="hidden-select">
    
  <option value="lt4">0.1 to 3.9 mm</option>
  <option value="4to5_9">4.0 to 5.9 mm</option>
  <option value="6to7_9">6.0 to 7.9 mm</option>
  <option value="ge8">&ge;8.0 mm</option>

  </select>

            </div>
          </div>

          <div id="mode_nonsolid" class="modebox" style="display:none">
            <div class="row">
  <label>Behavior on current exam</label>

  <div class="chip-group" id="lr_behavior_ns_chips" data-select="lr_behavior_ns" data-value="baseline">
    <button type="button" class="chip" data-val="baseline">Baseline</button><button type="button" class="chip" data-val="new">New</button><button type="button" class="chip" data-val=")</button><button type="button" class="chip" data-val="stable">Stable / decreased</button><button type="button" class="chip" data-val="slow_multi">Slow growth over multiple exams but &lt;1.5 mm per 12 mo</button>
  </div>
  <select id="lr_behavior_ns" class="hidden-select">
    
                <option value="baseline">Baseline</option>
                <option value="new">New</option>
                <option value=")</option>
                <option value="stable">Stable / decreased</option>
                <option value="slow_multi">Slow growth over multiple exams but &lt;1.5 mm per 12 mo</option>
              
  </select>

</div>
            <div class="row">
  <label>Total mean diameter</label>

  <div class="chip-group size-chip-group" id="lr_size_ns_chips" data-select="lr_size_ns_cat" data-value="6to7_9">
    <button type="button" class="chip" data-val="lt4">&lt;4.0 mm</button><button type="button" class="chip" data-val="4to5_9">4.0 to 5.9 mm</button><button type="button" class="chip" data-val="6to7_9">6.0 to 7.9 mm</button><button type="button" class="chip" data-val="8to9_9">8.0 to 9.9 mm</button><button type="button" class="chip" data-val="10to14_9">10.0 to 14.9 mm</button><button type="button" class="chip" data-val="15to29_9">15.0 to 29.9 mm</button><button type="button" class="chip" data-val="ge30">&ge;30.0 mm</button>
  </div>
  <select id="lr_size_ns_cat" class="hidden-select">
    
  <option value="lt4">&lt;4.0 mm</option>
  <option value="4to5_9">4.0 to 5.9 mm</option>
  <option value="6to7_9" selected>6.0 to 7.9 mm</option>
  <option value="8to9_9">8.0 to 9.9 mm</option>
  <option value="10to14_9">10.0 to 14.9 mm</option>
  <option value="15to29_9">15.0 to 29.9 mm</option>
  <option value="ge30">&ge;30.0 mm</option>

  </select>

</div>
          </div>

          <div id="mode_juxta" class="modebox" style="display:none">
            <div class="row">
  <label>Behavior on current exam</label>

  <div class="chip-group" id="lr_behavior_juxta_chips" data-select="lr_behavior_juxta" data-value="baseline">
    <button type="button" class="chip" data-val="baseline">Baseline</button><button type="button" class="chip" data-val="new">New</button>
  </div>
  <select id="lr_behavior_juxta" class="hidden-select">
    
                <option value="baseline" selected>Baseline</option>
                <option value="new">New</option>
              
  </select>

</div>
            <div class="row">
  <label>Total mean diameter</label>

  <div class="chip-group size-chip-group" id="lr_size_jp_chips" data-select="lr_size_juxta_cat" data-value="6to7_9">
    <button type="button" class="chip" data-val="lt4">&lt;4.0 mm</button><button type="button" class="chip" data-val="4to5_9">4.0 to 5.9 mm</button><button type="button" class="chip" data-val="6to7_9">6.0 to 7.9 mm</button><button type="button" class="chip" data-val="8to9_9">8.0 to 9.9 mm</button><button type="button" class="chip" data-val="10to14_9">10.0 to 14.9 mm</button><button type="button" class="chip" data-val="15to29_9">15.0 to 29.9 mm</button><button type="button" class="chip" data-val="ge30">&ge;30.0 mm</button>
  </div>
  <select id="lr_size_juxta_cat" class="hidden-select">
    
  <option value="lt4">&lt;4.0 mm</option>
  <option value="4to5_9">4.0 to 5.9 mm</option>
  <option value="6to7_9" selected>6.0 to 7.9 mm</option>
  <option value="8to9_9">8.0 to 9.9 mm</option>
  <option value="10to14_9">10.0 to 14.9 mm</option>
  <option value="15to29_9">15.0 to 29.9 mm</option>
  <option value="ge30">&ge;30.0 mm</option>

  </select>

</div>
            <div class="row">
              <label>Benign-appearing juxtapleural morphology?</label>
              <select id="lr_juxta_benign">
                <option value="yes" selected>Yes — Solid; smooth margins; and oval, lentiform, or triangular shape</option>
                <option value="no">No</option>
              </select>
            </div>
            </div>

          <div id="mode_airway" class="modebox" style="display:none">
            <div class="row">
  <label>Location</label>

  <div class="chip-group" id="airway_loc_chips" data-select="lr_airway_mode" data-value="subsegmental">
    <button type="button" class="chip" data-val="subsegmental">Subsegmental and/or multiple tubular</button><button type="button" class="chip" data-val="segmental_baseline">Segmental or more proximal - baseline</button><button type="button" class="chip" data-val="segmental_persistent">Segmental or more proximal - stable or growing</button>
  </div>
  <select id="lr_airway_mode" class="hidden-select">
    
                <option value="subsegmental">Subsegmental and/or multiple tubular</option>
                <option value="segmental_baseline">Segmental or more proximal - baseline</option>
                <option value="segmental_persistent">Segmental or more proximal - stable or growing</option>
              
  </select>

</div>
          </div>

          <div id="mode_cyst" class="modebox" style="display:none">
            <div class="row">
              
<label>Cyst subtype</label>
<div id="cyst_ui">
  <div>
    <label class="small-muted">Current morphology</label>
    <div class="chip-group" id="cyst_morph" data-value="thick">
      <button type="button" class="chip" data-val="thin">Thin-walled</button>
      <button type="button" class="chip" data-val="thick">Thick-walled</button>
      <button type="button" class="chip" data-val="multiloc">Multilocular</button>
    </div>
  </div>
  <div>
    <label class="small-muted">Status</label>
    <div class="chip-group" id="cyst_status" data-value="baseline">
      <button type="button" class="chip active" data-val="baseline">Baseline</button>
      <button type="button" class="chip" data-val="progression">Progression</button>
      </div>
  </div>
  <div id="cyst_prog_details" style="display:none">
    <label class="small-muted">Progression details</label>
    <div class="chip-group" id="cyst_progchips">
        <button type="button" class="chip" data-val="growing_cystic">Growing cystic component</button>
      <button type="button" class="chip chip-muted" data-val="becomes_multiloc">Becomes multilocular</button>
      <button type="button" class="chip chip-muted" data-val="increased_loculation">Increased loculation</button>
      <button type="button" class="chip chip-muted" data-val="growing_wall_or_nodularity">Growing wall thickness/nodularity</button>
      <button type="button" class="chip chip-muted" data-val="new_or_increased_opacity">New/increased opacity</button>
      <button type="button" class="chip chip-muted" data-val="growing_multiloc">Growing multilocular cyst</button>
    </div>
  </div>
  <!-- Hidden select preserved for compatibility with existing compute logic -->
  <select id="lr_cyst_mode" class="hidden-select">
    <option value="3_growing_cystic">3_growing_cystic</option>
    <option value="4a_thick_or_multiloc">4a_thick_or_multiloc</option>
    <option value="4b_progression">4b_progression</option>
    <option value="2_thin_baseline">2_thin_baseline</option>
  </select>
</div>

            </div>
          </div>

          <div id="mode_benign" class="modebox" style="display:none">
            <div class="muted">Benign calcified or fat-containing nodule, typical perifissural, etc.</div>
          </div>

          <div id="mode_none" class="modebox" style="display:none">
            <div class="muted">No lung nodules present.</div>
          </div>
        </div>
      </div>
      <div class="inline" style="margin-top:10px">
        <button id="lr_compute">Compute category</button>
        
        <button class="secondary" id="lr_reset">Reset</button>
        <div class="muted">ACR Lung-RADS® v2022.</div>
      </div>
    </div>

    <div class="card">
      <h2>Result</h2>
      <div id="lr_result" class="out">Fill inputs and click “Compute category”.</div>
      <div id="lr_notes" class="footer"></div>
    </div>
  </section>

  <details style="margin-top:12px">
    <summary>About &amp; references</summary>
    <p>Encodes: (1) ACR Lung-RADS® v2022 decision rules (screening) including airway/cyst special cases, slow-growing notes, and 4X features with S-modifier (S input hidden per your request); and (2) Fleischner Society 2017 recommendations for incidentally detected nodules in adults &ge;35 years (immunocompetent, no known cancer).</p>
    <p class="muted">Educational use only; verify against the full guideline text and institutional policy.</p>
  </details>
</div>

<script>
function setLrResult(cat){
  var el = byId('lr_result');
  if(!el) return;
  if(String(cat) === '1'){
    el.innerHTML = 'Category: <span class="badge-cat1">1</span>';
  }else{
    el.innerHTML = 'Category: ' + cat;
  }
}

(function(){
  function err(msg){ try{var bar=document.getElementById('errbar'); bar.textContent=msg; bar.style.display='block';}catch(e){} }
  window.addEventListener('error', function(e){ err('Script error: ' + (e.message||'(unknown)')); });

  function mm(v){ v=parseFloat(v); return isNaN(v)?0:v; }
  function byId(id){ return document.getElementById(id); }

  function setupTabs(){
    var btns = document.querySelectorAll('.tabbar button');
    function showTab(t){
      var i;
      for(i=0;i<btns.length;i++){ btns[i].classList.remove('active'); }
      for(i=0;i<btns.length;i++){
        if(btns[i].getAttribute('data-tab')===t){ btns[i].classList.add('active'); }
      }
      var secs=document.querySelectorAll('.section');
      for(i=0;i<secs.length;i++){ secs[i].classList.remove('active'); }
      byId(t).classList.add('active');
    }
    for(var i=0;i<btns.length;i++){
      (function(b){
        b.addEventListener('click', function(){ showTab(b.getAttribute('data-tab')); });
      })(btns[i]);
    }
  }

  /* ---------- Fleischner ---------- */
  function fl_updateSolidComp(){
    byId('fl_solidCompRow').style.display = (byId('fl_type').value==='partsolid')?'block':'none';
  }

  function fl_compute(){
    var agegrp = byId('fl_agegrp').value;
    var eligible = byId('fl_isEligible').value === 'yes';
    var risk = byId('fl_risk').value;
    var mult = byId('fl_multiplicity').value;
    var type = byId('fl_type').value;
    var sizecat = byId('fl_sizecat').value; // lt6, 6to8, gt8
    var sccat = byId('fl_sccat').value; // lt6, ge6

    if (agegrp === 'lt35' || !eligible){
      byId('fl_result').textContent = 'Fleischner not applicable.\nReasons:\n- Age <35 or immunocompromised/known cancer.\nManagement:\nUse disease-specific or oncologic guideline.';
      byId('fl_notes').innerHTML = '<div class="muted">Fleischner 2017 applies to incidentally detected nodules in adults &gt;35 years, immunocompetent, and without known cancer.</div>';
      return;
    }

    var rec = '', bullets = [];

    function singleSolid(){
      if (sizecat === 'lt6'){
        rec = (risk==='low') ? 'No routine follow-up.' : 'Optional CT at 12 months (consider if suspicious morphology, upper lobe location, or both).';
        bullets.push('Single solid <6 mm.');
        return;
      }
      if (sizecat === '6to8'){
        rec = (risk==='high') ? 'CT at 6–12 months, then CT at 18–24 months.' : 'CT at 6–12 months, then consider CT at 18–24 months.';
        bullets.push('Single solid 6–8 mm.');
        return;
      }
      if (sizecat === 'gt8'){
        rec = 'Consider CT at 3 months, PET/CT, or tissue sampling.';
        bullets.push('Single solid >8 mm.');
        return;
      }
    }

    function multipleSolid(){
      if (sizecat === 'lt6'){
        rec = (risk==='low') ? 'No routine follow-up.' : 'Optional CT at 12 months.';
        bullets.push('Multiple solid <6 mm (manage by most suspicious).');
        return;
      }
      if (sizecat === '6to8'){
        rec = (risk==='high') ? 'CT at 3–6 months, then at 18–24 months.' : 'CT at 3–6 months, then consider CT at 18–24 months.';
        bullets.push('Multiple solid 6–8 mm (manage by most suspicious).');
        return;
      }
      if (sizecat === 'gt8'){
        rec = (risk==='high') ? 'CT at 3–6 months, then at 18–24 months.' : 'CT at 3–6 months, then consider CT at 18–24 months.';
        bullets.push('Multiple solid >8 mm (manage by most suspicious).');
        return;
      }
    }

    function pureGGN(){
      if (sizecat === 'lt6'){
        rec = 'No routine follow-up.';
        bullets.push('Pure GGN <6 mm.');
        return;
      }
      rec = 'CT at 6–12 months to confirm persistence, then CT every 2 years until 5 years.';
      bullets.push('Pure GGN ≥6 mm.');
    }

    function partSolid(){
      if (sizecat === 'lt6'){
        rec = 'No routine follow-up.';
        bullets.push('Part‑solid total <6 mm.');
        return;
      }
      if (sizecat !== 'lt6' && sccat === 'lt6'){
        rec = 'CT at 3–6 months to confirm persistence. If unchanged and solid component remains <6 mm, annual CT should be performed for 5 years.';
        bullets.push('Part‑solid ≥6 mm total, solid <6 mm.');
        return;
      }
      if (sccat === 'ge6'){
        rec = 'CT at 3-6 months to confirm persistence. Persistent part-solid nodules with solid components ≥6 mm should be considered highly suspicious.';
        bullets.push('Part‑solid with solid ≥6 mm.');
        return;
      }
    }

    function multipleSubsolid(){
      if (sizecat === 'lt6'){
        rec = 'CT at 3–6 months. If stable, consider CT at 2 and 4 years.';
        bullets.push('Multiple subsolid <6 mm.');
      } else {
        rec = 'CT at 3–6 months. Subsequent management based on the most suspicious nodule(s).';
        bullets.push('Multiple subsolid ≥6 mm.');
      }
    }

    if (type === 'solid' && !(typeof juxtaHandled !== 'undefined' && juxtaHandled)) {
      if (mult === 'single') singleSolid(); else multipleSolid();
    } else if (type === 'nonsolid'){
      if (mult === 'single') pureGGN(); else multipleSubsolid();
    } else if (type === 'partsolid'){
      if (mult === 'single') partSolid(); else multipleSubsolid();
    }

    var txt = rec;
    byId('fl_result').textContent = txt;
    byId('fl_notes').innerHTML = '<div class="muted"></div>';
  }

  /* ---------- Lung-RADS ---------- */
  function _showErr(msg){
    try{ var bar=document.getElementById('errbar'); bar.textContent=msg; bar.style.display='block'; }catch(_e){}
  }
  function safeRun(name, fn){
    try { fn(); }
    catch(e){
      var m = 'Error in '+name+': ' + (e && e.message ? e.message : String(e));
      if (e && e.stack) { m += ' \n' + e.stack; }
      _showErr(m);
    }
  }

  function lr_diag(){
    var ids = [
      'lr_examSituation','lr_extraSuspicious','lr_mode',
      'lr_behavior_solid','lr_size_solid_cat',
      'lr_behavior_part','lr_size_part_cat','lr_solidComp_part_cat',
      'lr_behavior_ns','lr_size_ns_cat',
      'lr_behavior_juxta','lr_size_juxta_cat'
    ];
    var missing = [];
    for (var i=0;i<ids.length;i++){
      if (!byId(ids[i])) missing.push(ids[i]);
    }
    var msg = missing.length? ('Missing elements: '+missing.join(', ')) : 'OK: all expected inputs present';
    try{ document.getElementById('errbar').textContent = 'Diag → ' + msg; document.getElementById('errbar').style.display='block'; }catch(e){}
    return msg;
  }

  function showMode(){
    var m = byId('lr_mode').value;
    var ids = ['mode_solid','mode_partsolid','mode_nonsolid','mode_juxta','mode_airway','mode_cyst','mode_benign','mode_none'];
    for (var i=0;i<ids.length;i++){ byId(ids[i]).style.display = (ids[i]==='mode_'+m)?'block':'none'; }
    if(m==='partsolid'){ togglePartSolidSC(); }
    if(m==='partsolid'){ ensurePartListeners(); setTimeout(togglePartSolidSC, 0); }
  }

  function lr_compute(){
    // Preflight presence checks per mode to catch any missing elements
    var _mdEl = byId('lr_mode'); var _mdVal = _mdEl ? _mdEl.value : 'solid';
    var missing = [];
    function need(id){ if(!byId(id)) missing.push(id); }
    if (_mdVal==='solid' || _mdVal==='juxta'){
      need('lr_behavior_solid'); need(_mdVal==='solid'?'lr_size_solid_cat':'lr_size_juxta_cat');
    } else if (_mdVal==='partsolid'){
      need('lr_behavior_part'); need('lr_size_part_cat'); need('lr_solidComp_part_cat');
    } else if (_mdVal==='nonsolid'){
      need('lr_behavior_ns'); need('lr_size_ns_cat');
    } else if (_mdVal==='airway'){
      need('lr_airway_mode');
    } else if (_mdVal==='cyst'){
      need('lr_cyst_mode');
    }
    if (missing.length){
      _showErr('Missing required element(s): '+missing.join(', '));
      return;
    }
    var _es = byId('lr_examSituation'); var situation = _es? _es.value : 'routine';
    var _ex = byId('lr_extraSuspicious'); var extra = _ex? _ex.value : 'none'; // none, spiculation, lad, mets, ggn_double
    var _md = byId('lr_mode'); var mode = _md? _md.value : 'solid'; // solid, partsolid, nonsolid, juxta, airway, cyst, benign, none

    var cat=null, reason=[], management='';
    var lrMgmt = {
      "0_prior": "Comparison to prior chest CT; additional lung cancer screening CT imaging needed.",
      "0_infect": "1–3 month LDCT (indeterminate infectious/inflammatory process).",
      "1": "12-month screening LDCT.",
      "2": "12-month screening LDCT.",
      "3": "6-month LDCT.",
      "4A": "3-month LDCT; PET/CT may be considered if there is a ≥ 8 mm solid nodule or solid component.",
      "4B": "Referral for further clinical evaluation. Diagnostic chest CT (± IV contrast); PET/CT may be considered if there is a ≥ 8 mm solid nodule or solid component; tissue sampling and/or surgical evaluation as appropriate.",
      "4X": "Manage as 4B with attention to additional high-risk features (spiculation, lymphadenopathy, frank metastasis)."
    };

    if (situation === 'awaiting_prior'){ cat='0'; management=lrMgmt["0_prior"]; reason.push("Prior chest CT being located."); }
    else if (situation === 'suspected_infectious'){ cat='0'; management=lrMgmt["0_infect"]; reason.push("Indeterminate infectious/inflammatory process."); }

    if (!cat){
      if (mode === 'none'){
        cat='1'; management=lrMgmt["1"]; reason.push("No lung nodules present → 1.");
      } else if (mode === 'benign'){
        cat='1'; management=lrMgmt["1"]; reason.push("Benign calcified/fat-containing or typical benign morphology → 1.");
      } else if (mode === 'airway'){
        var airwaySel = byId('lr_airway_mode').value;
        if (airwaySel === 'subsegmental'){ cat='2'; management=lrMgmt["2"]; reason.push("Subsegmental/multiple tubular airway abnormality → 2."); }
        else if (airwaySel === 'segmental_baseline'){ cat='4A'; management=lrMgmt["4A"]; reason.push("Segmental/proximal airway nodule at baseline → 4A."); }
        else if (airwaySel === 'segmental_persistent'){ cat='4B'; management=lrMgmt["4B"]; reason.push("Segmental/proximal airway nodule persistent at 3‑mo FU → 4B."); }
      } else if (mode === 'cyst'){
        var cystSel = byId('lr_cyst_mode').value;
        if (cystSel === '3_growing_cystic'){ cat='3'; management=lrMgmt["3"]; reason.push("Atypical pulmonary cyst with growing cystic component → 3."); }
        if (cystSel === '4a_thick_or_multiloc'){ cat='4A'; management=lrMgmt["4A"]; reason.push("Thick‑walled or multilocular cyst at baseline → 4A."); }
        if (cystSel === '4b_progression'){ cat='4B'; management=lrMgmt["4B"]; reason.push("Progressive thick wall/nodularity/loculation/opacities → 4B."); }
      } else {
        var type = (mode==='solid'?'solid': (mode==='partsolid'?'partsolid': (mode==='nonsolid'?'nonsolid':'solid')));
        var behavior, size, sc=0;
        // Map dropdown categories to numeric upper bounds for threshold logic
        function catToUpper(cat){
          if (cat==='lt4') return 3.9;
          if (cat==='4to5_9') return 5.9;
          if (cat==='6to7_9') return 7.9;
          if (cat==='8to9_9') return 9.9;
          if (cat==='10to14_9') return 14.9;
          if (cat==='15to29_9') return 29.9;
          if (cat==='ge30') return 999;
          return 0;
        }
        function scCatToUpper(cat){
          if (cat==='lt4') return 3.9;
          if (cat==='4to5_9') return 5.9;
          if (cat==='6to7_9') return 7.9;
          if (cat==='ge8') return 999;
          return 0;
        }
        if (mode==='solid' || mode==='juxta'){
        // Normalize juxta behavior to allowed set (baseline/new) just in case
        if (mode==='juxta'){
          var _bj = byId('lr_behavior_juxta'); 
          if (_bj && _bj.value !== 'baseline' && _bj.value !== 'new'){ _bj.value = 'baseline'; }
        }
          var _bs = byId('lr_behavior_solid'); behavior = _bs? _bs.value : 'baseline';
          size = catToUpper(byId(mode==='solid'?'lr_size_solid_cat':'lr_size_juxta_cat').value);
        
          // Juxtapleural benign morphology special case: <10 mm + benign → category 2
          var juxtaHandled = false;
          if (mode==='juxta'){
            var jbEl = byId('lr_juxta_benign');
            var jb = jbEl ? jbEl.value : 'no';
            if (size < 10 && jb === 'yes'){
              cat='2'; management=lrMgmt["2"]; reason.push("Juxtapleural benign morphology <10 mm → 2.");
              juxtaHandled = true;
            }
          }
    } else if (mode==='partsolid'){
          var _bp = byId('lr_behavior_part'); behavior = _bp? _bp.value : 'baseline';
          size = catToUpper(byId('lr_size_part_cat').value);
          sc = scCatToUpper(byId('lr_solidComp_part_cat').value);
        } else if (mode==='nonsolid'){
          var _bn = byId('lr_behavior_ns'); behavior = _bn? _bn.value : 'baseline';
          size = catToUpper(byId('lr_size_ns_cat').value);
        }

        if (type === 'solid' && !(typeof juxtaHandled !== 'undefined' && juxtaHandled)) {
          if (behavior === 'baseline'){
            if (size < 6){ cat='2'; management=lrMgmt["2"]; reason.push("Solid <6 mm at baseline → 2."); }
            else if (size < 8){ cat='3'; management=lrMgmt["3"]; reason.push("Solid ≥6 to <8 mm at baseline → 3."); }
            else if (size < 15){ cat='4A'; management=lrMgmt["4A"]; reason.push("Solid ≥8 to <15 mm at baseline → 4A."); }
            else { cat='4B'; management=lrMgmt["4B"]; reason.push("Solid ≥15 mm at baseline → 4B."); }
          } else if (behavior === 'new'){
            if (size < 4){ cat='2'; management=lrMgmt["2"]; reason.push("New solid <4 mm → 2."); }
            else if (size < 6){ cat='3'; management=lrMgmt["3"]; reason.push("New solid 4 to <6 mm → 3."); }
            else if (size < 8){ cat='4A'; management=lrMgmt["4A"]; reason.push("New solid 6 to <8 mm → 4A."); }
            else { cat='4B'; management=lrMgmt["4B"]; reason.push("New solid ≥8 mm → 4B."); }
          } else if (behavior === 'growing'){
            if (size < 8){ cat='4A'; management=lrMgmt["4A"]; reason.push("Growing solid <8 mm → 4A."); }
            else { cat='4B'; management=lrMgmt["4B"]; reason.push("Growing solid ≥8 mm → 4B."); }
          } else if (behavior === 'stable'){
            if (size < 6){ cat='2'; management=lrMgmt["2"]; reason.push("Stable solid <6 mm → 2."); }
            else if (size < 8){ cat='3'; management=lrMgmt["3"]; reason.push("Stable solid 6 to <8 mm → 3."); }
            else if (size < 15){ cat='4A'; management=lrMgmt["4A"]; reason.push("Stable solid ≥8 to <15 mm → 4A."); }
            else { cat='4B'; management=lrMgmt["4B"]; reason.push("Stable solid ≥15 mm → 4B."); }
          } else if (behavior === 'slow_multi'){
            cat='4B'; management=lrMgmt["4B"]; reason.push("Slow-growing solid over multiple exams (<1.5 mm/12 mo each) → 4B.");
          }
        }

        if (!cat && type === 'partsolid'){
        if (behavior === 'baseline') {
          if (size < 6) { cat='2'; management=lrMgmt["2"]; reason.push("Part‑solid total <6 mm at baseline → 2."); }
          else {
            if (sc < 6) { cat='3'; management=lrMgmt["3"]; reason.push("Part‑solid ≥6 mm total with solid <6 mm → 3."); }
            else if (sc < 8) { cat='4A'; management=lrMgmt["4A"]; reason.push("Part‑solid with solid ≥6 to <8 mm → 4A."); }
            else { cat='4B'; management=lrMgmt["4B"]; reason.push("Part‑solid with solid ≥8 mm → 4B."); }
          }
        } else if (behavior === 'new_nodule' || behavior === 'new') {
          if (size < 6) { cat='3'; management=lrMgmt["3"]; reason.push("New part‑solid nodule <6 mm total → 3."); }
          else {
            if (sc < 4) { cat='4A'; management=lrMgmt["4A"]; reason.push("New/growing solid component <4 mm → 4A."); }
            else { cat='4B'; management=lrMgmt["4B"]; reason.push("New/growing solid component ≥4 mm → 4B."); }
          }
        } else if (behavior === 'new_solid') {
          if (sc < 4) { cat='4A'; management=lrMgmt["4A"]; reason.push("New or growing solid component in existing nodule <4 mm → 4A."); }
          else { cat='4B'; management=lrMgmt["4B"]; reason.push("New or growing solid component in existing nodule ≥4 mm → 4B."); }
        } else if (behavior === 'growing' || behavior === 'growing_solid') {
          if (sc < 8) { cat='4A'; management=lrMgmt["4A"]; reason.push("Growing part‑solid with solid <8 mm → 4A."); }
          else { cat='4B'; management=lrMgmt["4B"]; reason.push("Growing part‑solid with solid ≥8 mm → 4B."); }
        }
    }

        if (!cat && type === 'nonsolid'){
          if (behavior === 'baseline' || behavior === 'new'){
            if (size < 30){ cat='2'; management=lrMgmt["2"]; reason.push("Non‑solid (GGN) <30 mm (baseline/new/stable) → 2."); }
            else { cat='3'; management=lrMgmt["3"]; reason.push("Non‑solid (GGN) ≥30 mm baseline/new → 3."); }
          }
          if (behavior === 'stable'){
            // Non‑solid (GGN) stable/decreased → 2 regardless of size
            cat='2'; management=lrMgmt["2"]; reason.push("Non‑solid (GGN) stable/decreased → 2.");
          }

          if (behavior === 'growing'){
            if (size < 30){ cat='2'; management=lrMgmt["2"]; reason.push("Non‑solid with growth but <30 mm → 2 until meets other criteria."); }
            else { cat='3'; management=lrMgmt["3"]; reason.push("Non‑solid ≥30 mm with growth → 3."); }
          }
          if (behavior === 'slow_multi'){
            cat='2'; management=lrMgmt["2"]; reason.push("Slow‑growing pure GGN over multiple exams → 2 until meets other criteria.");
          }
        }
      }
    }

    // 4X override
    if (cat && (cat==='3' || cat==='4A' || cat==='4B') && extra!=='none'){
      cat='4X'; management=lrMgmt["4X"]; reason.push("Additional suspicious feature present → upgrade to 4X.");
    }

    if (!cat){ cat="Unable to categorize"; management="Check inputs."; }
    byId('lr_result').textContent = 'Category: ' + cat + '\nReasons:\n- ' + reason.join('\n- ') + '\nManagement: ' + (typeof management!=='undefined' ? management : '');
    // HARD OVERRIDE for Thick-walled cyst → Progression → Growing cystic component
    (function(){
      try{
        var modeSel = byId('lr_mode');
        if (modeSel && modeSel.value === 'cyst'){
          var morphEl = byId('cyst_morph');
          var statusEl = byId('cyst_status');
          var detailsEl = byId('cyst_progchips');
          if (morphEl && statusEl && detailsEl){
            var m = morphEl.dataset.value || '';
            var s = statusEl.dataset.value || '';
            var det = null;
            var act = detailsEl.querySelector('.chip.active');
            if (act) det = act.getAttribute('data-val');
            if (m==='thick' && s==='progression' && det==='growing_cystic'){
              var out = byId('lr_result');
              if (out){
                out.textContent = 'Category: 3\\nManagement: 6-month LDCT.';
              }
            }
          }
        }
      }catch(e){}
    })();

    byId('lr_notes').innerHTML = '<div class="muted">Notes: Short-interval FU downgrades may apply per Lung-RADS v2022.</div>';
  }

  /* ---------- QA (Fleischner) ---------- */
  function runFlTest(cfg){
    var btns=document.querySelectorAll('.tabbar button');
    for(var i=0;i<btns.length;i++){ if(btns[i].getAttribute('data-tab')==='fleischner'){ btns[i].click(); break; } }
    byId('fl_isEligible').value = cfg.eligible || 'yes';
    byId('fl_agegrp').value = cfg.agegrp || 'ge35';
    byId('fl_risk').value = cfg.risk || 'low';
    byId('fl_multiplicity').value = cfg.mult || 'single';
    byId('fl_type').value = cfg.type || 'solid';
    var sz = (typeof cfg.size!=='undefined')? cfg.size : 6;
    var scv = (typeof cfg.sc!=='undefined')? cfg.sc : 0;
    byId('fl_sizecat').value = (sz < 6) ? 'lt6' : ((sz <= 8) ? '6to8' : 'gt8');
    byId('fl_sccat').value = (scv < 6) ? 'lt6' : 'ge6';
    fl_updateSolidComp();
    fl_compute();
    var got = byId('fl_result').textContent || '';
    var pass = got.indexOf(cfg.expect) !== -1;
    var status = pass ? '✅ PASS' : '❌ FAIL';
    byId('qa_status').textContent = status + ' — ' + (pass ? 'expected phrase present' : 'expected phrase NOT present');
    byId('fl_result').scrollIntoView(true);
  }

  function buildQA(){
    var qaItems = [
      {title:'solid, single, low risk, 5 mm', c:{type:'solid',mult:'single',risk:'low',size:5}, expect:'No routine follow-up.'},
      {title:'solid, single, low risk, 6 mm', c:{type:'solid',mult:'single',risk:'low',size:6}, expect:'CT at 6–12 months, then consider CT at 18–24 months.'},
      {title:'solid, single, low risk, 9 mm', c:{type:'solid',mult:'single',risk:'low',size:9}, expect:'Consider CT at 3 months, PET/CT, or tissue sampling.'},
      {title:'solid, single, high risk, 5 mm', c:{type:'solid',mult:'single',risk:'high',size:5}, expect:'Optional CT at 12 months (consider if suspicious morphology, upper lobe location, or both).'},
      {title:'solid, single, high risk, 6 mm', c:{type:'solid',mult:'single',risk:'high',size:6}, expect:'CT at 6–12 months, then CT at 18–24 months.'},
      {title:'solid, single, high risk, 9 mm', c:{type:'solid',mult:'single',risk:'high',size:9}, expect:'Consider CT at 3 months, PET/CT, or tissue sampling.'},
      {title:'solid, multiple, low risk, 5 mm', c:{type:'solid',mult:'multiple',risk:'low',size:5}, expect:'No routine follow-up.'},
      {title:'solid, multiple, low risk, 6 mm', c:{type:'solid',mult:'multiple',risk:'low',size:6}, expect:'CT at 3–6 months, then consider CT at 18–24 months.'},
      {title:'solid, multiple, low risk, 9 mm', c:{type:'solid',mult:'multiple',risk:'low',size:9}, expect:'CT at 3–6 months, then consider CT at 18–24 months.'},
      {title:'solid, multiple, high risk, 5 mm', c:{type:'solid',mult:'multiple',risk:'high',size:5}, expect:'Optional CT at 12 months.'},
      {title:'solid, multiple, high risk, 6 mm', c:{type:'solid',mult:'multiple',risk:'high',size:6}, expect:'CT at 3–6 months, then at 18–24 months.'},
      {title:'solid, multiple, high risk, 9 mm', c:{type:'solid',mult:'multiple',risk:'high',size:9}, expect:'CT at 3–6 months, then at 18–24 months.'},
      {title:'ground glass, single, 5 mm', c:{type:'nonsolid',mult:'single',risk:'low',size:5}, expect:'No routine follow-up.'},
      {title:'ground glass, single 6 mm with 3 mm solid component', c:{type:'partsolid',mult:'single',risk:'low',size:6,sc:3}, expect:'CT at 3–6 months to confirm persistence. If unchanged and solid component remains <6 mm, annual CT should be performed for 5 years.'},
      {title:'part-solid, single, 5 mm', c:{type:'partsolid',mult:'single',risk:'low',size:5,sc:0}, expect:'No routine follow-up.'},
      {title:'part-solid, single, 6 mm with 3 mm solid', c:{type:'partsolid',mult:'single',risk:'low',size:6,sc:3}, expect:'CT at 3–6 months to confirm persistence. If unchanged and solid component remains <6 mm, annual CT should be performed for 5 years.'},
      {title:'ground glass, multiple, 5 mm', c:{type:'nonsolid',mult:'multiple',risk:'low',size:5}, expect:'CT at 3–6 months. If stable, consider CT at 2 and 4 years.'},
      {title:'ground glass, multiple, 6 mm with 3 mm solid', c:{type:'partsolid',mult:'multiple',risk:'low',size:6,sc:3}, expect:'CT at 3–6 months. Subsequent management based on the most suspicious nodule(s).'},
      {title:'part-solid, multiple, 5 mm', c:{type:'partsolid',mult:'multiple',risk:'low',size:5,sc:0}, expect:'CT at 3–6 months. If stable, consider CT at 2 and 4 years.'},
      {title:'part-solid, multiple, 6 mm with 3 mm solid', c:{type:'partsolid',mult:'multiple',risk:'low',size:6,sc:3}, expect:'CT at 3–6 months. Subsequent management based on the most suspicious nodule(s).'}
    ];

    var grid = byId('qa_grid');
    for(var i=0;i<qaItems.length;i++){
      var item = qaItems[i];
      var card = document.createElement('div');
      card.className = 'card';
      card.style.padding = '10px';

      var title = document.createElement('strong');
      title.appendChild(document.createTextNode((i+1)+'. '+item.title));

      var exp = document.createElement('div');
      exp.className = 'muted';
      exp.appendChild(document.createTextNode('Expect: “'+item.expect+'”'));

      var btn = document.createElement('button');
      btn.appendChild(document.createTextNode('Run test'));
      (function(cfg, expect){
        btn.addEventListener('click', function(){
          cfg.expect = expect;
          runFlTest(cfg);
        });
      })({agegrp:'ge35', eligible:'yes', type:item.c.type, mult:item.c.mult, risk:item.c.risk, size:item.c.size, sc:item.c.sc}, item.expect);

      card.appendChild(title);
      card.appendChild(exp);
      card.appendChild(btn);
      grid.appendChild(card);
    }
  }

  
  // Hide solid component for part-solid when Baseline + total mean <6 mm
  function togglePartSolidSC(){
  var behEl = document.getElementById('lr_behavior_part');
  var sizeEl = document.getElementById('lr_size_part_cat');
  var row = document.getElementById('lr_solidCompRow_part');
  if(!row) return;
  var beh = behEl && behEl.value ? behEl.value : 'baseline';
  var sizeCat = sizeEl && sizeEl.value ? sizeEl.value : '6to7_9';
  var isLt6 = (sizeCat === 'lt4' || sizeCat === '4to5_9');
  var hide = ((beh === 'baseline' || beh === 'new_nodule') && isLt6);
  row.style.display = hide ? 'none' : 'block';
}

  var _partListenersAttached = false;
  function ensurePartListeners(){
    if (_partListenersAttached) return;
    var behEl = document.getElementById('lr_behavior_part');
    var sizeEl = document.getElementById('lr_size_part_cat');
    if (behEl) { behEl.addEventListener('change', togglePartSolidSC); behEl.addEventListener('input', togglePartSolidSC); }
    if (sizeEl) { sizeEl.addEventListener('change', togglePartSolidSC); sizeEl.addEventListener('input', togglePartSolidSC); }
    _partListenersAttached = true;
  }

  // Part-solid: hide Solid component when (Baseline or New) AND total mean < 6 mm
  function togglePartSolidSC(){
  var behEl = document.getElementById('lr_behavior_part');
  var sizeEl = document.getElementById('lr_size_part_cat');
  var row = document.getElementById('lr_solidCompRow_part');
  if(!behEl || !sizeEl || !row) return;
  var beh = behEl.value;
  var sizeCat = sizeEl.value; // lt4, 4to5_9, 6to7_9, ...
  var isLt6 = (sizeCat === 'lt4' || sizeCat === '4to5_9');
  // Hide only if Baseline OR New nodule AND size < 6 mm
  row.style.display = ((beh === 'baseline' || beh === 'new_nodule') && isLt6) ? 'none' : 'block';
}

// ---- Cyst chips wiring (Option C) ----

function setupCystChips(){
  
  
  
  // Map current UI selections to hidden select for compute
  function setCystHiddenFromUI(){
    try{
      var morph = byId('cyst_morph');
      var status = byId('cyst_status');
      var details = byId('cyst_progchips');
      var hidden = byId('lr_cyst_mode');
      if(!morph || !status || !hidden) return;
      var m = morph.dataset.value || '';
      var s = status.dataset.value || '';
      var det = null;
      if (details){
        var act = details.querySelector('.chip.active');
        det = act ? act.getAttribute('data-val') : null;
      }
      // Defaults
      var code = hidden.value;
      // Thick-walled mapping
      if (m==='thick'){
        if (s==='baseline'){
          // Thick baseline (no progression) → 4A per spec (thick-walled at baseline)
          code = '4a_thick_or_multiloc';
        } else if (s==='progression'){
          if (det === 'becomes_multiloc'){ code = '4a_thick_or_multiloc'; }
          else if (det === 'growing_wall_or_nodularity'){ code = '4b_progression'; }
          else if (det === 'growing_cystic'){ code = '3_growing_cystic'; }
          else { code = '3_growing_cystic'; }
        }
      } else if (m==='thin'){
        // Thin baseline → 2; thin progression becomes multiloc → 4A; others could vary
        if (s==='baseline'){ code = '2_thin_baseline'; }
        else if (s==='progression'){
          if (det === 'becomes_multiloc'){ code = '4a_thick_or_multiloc'; }
          else { code = '3_growing_cystic'; }
        }
      }
      hidden.value = code;
    }catch(e){ /* no-op */ }
  }

// Dynamically enforce cyst UI based on morphology/status
  function enforceCystUI(){
    try{
      var morph = byId('cyst_morph');
      var status = byId('cyst_status');
      var details = byId('cyst_progchips');
      if(!morph || !status || !details) return;
      var m = morph.dataset.value || 'thin';
      var s = status.dataset.value || 'baseline';

      // Progression detail options for thick-walled only
      var allowedThickProgress = ['growing_cystic','becomes_multiloc','growing_wall_or_nodularity'];

      // Normalize: show all by default (we'll hide selectively)
      var detBtns = details.querySelectorAll('.chip');
      for (var i=0;i<detBtns.length;i++){ detBtns[i].style.display = ''; 
      // Multilocular morphology: status free, but when progression, show only these three details
      if (m === 'multiloc') {
        if (s === 'progression') {
          var allowedMulti = ['growing_multiloc', 'increased_loculation', 'new_increased_opacity'];
          for (var mm=0; mm<detBtns.length; mm++) {
            var dv2 = detBtns[mm].getAttribute('data-val');
            detBtns[mm].style.display = (allowedMulti.indexOf(dv2) !== -1) ? '' : 'none';
          
        // Explicitly hide thick-walled-only detail options
        var thickOnly = ['growing_cystic','becomes_multiloc','growing_wall_or_nodularity'];
        for (var tx=0; tx<thickOnly.length; tx++){
          var elx = details && details.querySelector('.chip[data-val="'+thickOnly[tx]+'"]');
          if (elx) elx.style.display = 'none';
        }}
          // enforce order
          var details = byId('cyst_progchips');
          ['growing_multiloc', 'increased_loculation', 'new_increased_opacity'].forEach(function(key){
            var el = details && details.querySelector('.chip[data-val="'+key+'"]');
            if (el && details) details.appendChild(el);
          });
        } else {
          // Baseline or other: hide progression details and clear selection
          var details = byId('cyst_progchips');
          var act2 = details ? details.querySelectorAll('.chip.active') : [];
          for (var k3=0; k3<act2.length; k3++){ act2[k3].classList.remove('active'); }
          for (var dd=0; dd<detBtns.length; dd++){ detBtns[dd].style.display = 'none'; }
        }
      }
}

      if (m === 'thick') {
        // Status options must be only Baseline/Progression (keep prior logic if present elsewhere)
        var stBtns = status.querySelectorAll('.chip');
        for (var j=0;j<stBtns.length;j++){
          var v = stBtns[j].getAttribute('data-val');
          var keep = (v === 'baseline' || v === 'progression');
          stBtns[j].style.display = keep ? '' : 'none';
        }
        if (s !== 'baseline' && s !== 'progression'){
          setActive(status, 'baseline');
          s = 'baseline';
        }

        // If status = Progression, show only 3 specific detail options and enforce order
        if (s === 'progression'){
          for (var k=0;k<detBtns.length;k++){
            var dv = detBtns[k].getAttribute('data-val');
            detBtns[k].style.display = (allowedThickProgress.indexOf(dv) !== -1) ? '' : 'none';
          }
          // enforce order
          allowedThickProgress.forEach(function(key){
            var el = details.querySelector('.chip[data-val="'+key+'"]');
            if (el) details.appendChild(el);
          });
        } else {
          // If not progression, clear any active selection in details
          var act = details.querySelectorAll('.chip.active');
          for (var a=0;a<act.length;a++){ act[a].classList.remove('active'); }
          // Optionally hide all details while baseline (comment out next 3 lines to keep visible but inactive)
          for (var k2=0;k2<detBtns.length;k2++){ detBtns[k2].style.display = 'none'; }
        }
      } else {
        // Non-thick morphology: make sure everything is visible (no restriction here)
        var stBtnsAll = status.querySelectorAll('.chip');
        for (var j2=0;j2<stBtnsAll.length;j2++){ stBtnsAll[j2].style.display = ''; }
        for (var i2=0;i2<detBtns.length;i2++){ detBtns[i2].style.display = ''; }
      }
    }catch(e){ /* no-op */ }
  }

// Enforce UI constraints for Thick-walled morphology
  function enforceThickUI(){
    try{
      var morph = byId('cyst_morph');
      var status = byId('cyst_status');
      var details = byId('cyst_progchips');
      if(!morph || !status || !details) return;
      var m = morph.dataset.value || 'thin';
      var s = status.dataset.value || 'baseline';

      var statusBtns = status.querySelectorAll('.chip');
      var detailBtns = details.querySelectorAll('.chip');

      if(m === 'thick'){
        // Only Baseline and Progression in Status
        for (var i=0;i<statusBtns.length;i++){
          var v = statusBtns[i].getAttribute('data-val');
          var keep = (v === 'baseline' || v === 'progression');
          statusBtns[i].style.display = keep ? '' : 'none';
        }
        if (s !== 'baseline' && s !== 'progression'){
          setActive(status, 'baseline');
          s = 'baseline';
        }
        // Only 3 details in a specific order
        var order = ['growing_cystic', 'becomes_multiloc', 'growing_wall_or_nodularity'];
        for (var j=0;j<detailBtns.length;j++){
          var dv = detailBtns[j].getAttribute('data-val');
          var keepD = (order.indexOf(dv) !== -1);
          detailBtns[j].style.display = keepD ? '' : 'none';
        }
        // Reorder DOM nodes to the desired order
        order.forEach(function(key){
          var el = details.querySelector('.chip[data-val="'+key+'"]');
          if (el) details.appendChild(el);
        });
        // If not progression, clear any active detail selection
        if (s !== 'progression'){
          var act = details.querySelectorAll('.chip.active');
          for (var k=0;k<act.length;k++){ act[k].classList.remove('active'); }
        }
      } else {
        // Leaving thick: unhide everything
        for (var i2=0;i2<statusBtns.length;i2++){ statusBtns[i2].style.display = ''; }
        for (var j2=0;j2<detailBtns.length;j2++){ detailBtns[j2].style.display = ''; }
      }
    }catch(e){}
  }

var morph = byId('cyst_morph'), status = byId('cyst_status'),
      detailsWrap = byId('cyst_prog_details'), details = byId('cyst_progchips'),
      hidden = byId('lr_cyst_mode');
  if(!morph || !status || !hidden) return;

  function setActive(group, val, exclusive){
    if (exclusive === undefined) exclusive = true;
    group.dataset.value = val;
    var btns = group.querySelectorAll('.chip');
    for (var i=0;i<btns.length;i++){
      var btn = btns[i];
      var isMe = (btn.getAttribute('data-val')===val);
      if(exclusive){
        btn.classList.toggle('active', isMe);
      }
    }
  }

  function toggleDetail(btn){
    // make selection mutually exclusive within the same chip group
    var group = btn.parentElement;
    if (!group) { btn.classList.toggle('active'); return; }
    var wasActive = btn.classList.contains('active');
    var chips = group.querySelectorAll('.chip');
    for (var i=0;i<chips.length;i++){ chips[i].classList.remove('active'); }
    if (!wasActive){ btn.classList.add('active'); }
  }

  function recomputeHidden(){
    var m = morph.dataset.value || 'thin';
    var s = status.dataset.value || 'baseline';
    // Constrain options for THIN-WALLED cyst:
    try {
      // Show only 'Progression' in Status if morph is thin
      var statusBtns = status.querySelectorAll('.chip');
      for (var i=0;i<statusBtns.length;i++){
        var v = statusBtns[i].getAttribute('data-val');
        if (m==='thin'){
          statusBtns[i].style.display = (v==='progression') ? '' : 'none';
        
/* --- OVERRIDE: Correct thick-walled cyst progression mapping --- */
try {
  // Ensure these refs exist
  if (typeof morph !== 'undefined' && typeof status !== 'undefined') {
    var m = morph && morph.dataset ? morph.dataset.value : null;
    var s = status && status.dataset ? status.dataset.value : null;
    var details = document.getElementById('cyst_progchips');
    if (m === 'thick' && s === 'progression' && details) {
      // Collect active detail values
      var chips = details.querySelectorAll('.chip');
      var active = [];
      for (var i = 0; i < chips.length; i++) {
        if (chips[i].classList.contains('active')) {
          var v = chips[i].getAttribute('data-val');
          if (v) active.push(v);
        
/* --- OVERRIDE 3: Correct mapping for Thick-walled cyst (Progression) --- */
try {
  var morphEl = byId('cyst_morph');
  var statusEl = byId('cyst_status');
  var detailsEl = byId('cyst_progchips');
  var hv = byId('lr_cyst_mode');
  if (morphEl && statusEl && detailsEl && hv) {
    var m = morphEl.dataset.value || '';
    var s = statusEl.dataset.value || '';
    if (m === 'thick' && s === 'progression') {
      var activeVal = null;
      var chips = detailsEl.querySelectorAll('.chip');
      for (var i=0;i<chips.length;i++){
        if (chips[i].classList.contains('active')){
          activeVal = chips[i].getAttribute('data-val');
          break;
        }
      }
      if (activeVal === 'becomes_multiloc') {
        hv.value = '4a_thick_or_multiloc';
      } else if (activeVal === 'growing_wall_or_nodularity') {
        hv.value = '4b_progression';
      } else if (activeVal === 'growing_cystic') {
        hv.value = '3_growing_cystic';
      } else {
        // default
        hv.value = '3_growing_cystic';
      }
    }
  }
} catch(__e) { /* no-op */ }
/* --- END OVERRIDE 3 --- */
  setCystHiddenFromUI();
}
      }
      // Apply correct mapping:
      //  - becomes_multiloc -> 4A
      //  - growing_wall_or_nodularity -> 4B
      //  - growing_cystic -> 3
      if (active.indexOf('becomes_multiloc') !== -1) {
        hidden.value = '4a_thick_or_multiloc';
      } else if (active.indexOf('growing_wall_or_nodularity') !== -1) {
        hidden.value = '4b_progression';
      } else if (active.indexOf('growing_cystic') !== -1) {
        hidden.value = '3_growing_cystic';
      } else {
        hidden.value = '3_growing_cystic';
      }
    }
    // If a direct "growing_cystic" status is ever used, force 3
    if (s === 'growing_cystic') {
      hidden.value = '3_growing_cystic';
    }
  }
} catch (_e) { /* no-op */ }
/* --- END OVERRIDE --- */
} else {
          statusBtns[i].style.display = '';
        }
      }
      // Force status to 'progression' when thin
      if (m==='thin' && s!=='progression'){
        setActive(status, 'progression');
        s = 'progression';
      }
      // Show only 'becomes_multiloc' in Progression details when thin
      if (typeof details !== 'undefined' && details){
        var detBtns = details.querySelectorAll('.chip');
        for (var j=0;j<detBtns.length;j++){
          var dv = detBtns[j].getAttribute('data-val');
          if (m==='thin'){
            detBtns[j].style.display = (dv==='becomes_multiloc') ? '' : 'none';
          } else {
            detBtns[j].style.display = '';
          }
        }
        // Auto-activate becomes_multiloc if morph thin and status progression

    // Constrain options for THICK-WALLED cyst:
    try {
      if (m==='thick') {
        // Show only Baseline and Progression in Status
        var statusBtns2 = status.querySelectorAll('.chip');
        for (var i2=0;i2<statusBtns2.length;i2++){
          var v2 = statusBtns2[i2].getAttribute('data-val');
          statusBtns2[i2].style.display = (v2==='baseline' || v2==='progression') ? '' : 'none';
        }
        if (s!=='baseline' && s!=='progression'){
          setActive(status, 'baseline');
          s = 'baseline';
        }

        // Ensure 'growing_cystic' is available as a details chip (clone from status if missing)
        if (typeof details !== 'undefined' && details){
          var gcDetail = details.querySelector('.chip[data-val="growing_cystic"]');
          if (!gcDetail) {
            var gcStatus = status.querySelector('.chip[data-val="growing_cystic"]');
            if (gcStatus){
              var clone = gcStatus.cloneNode(true);
              clone.setAttribute('data-cloned', '1');
              // ensure muted style initially
              clone.classList.remove('active'); 
              if (!clone.classList.contains('chip-muted')) clone.classList.add('chip-muted');
              details.appendChild(clone);
            }
          }
          // Show only the three detail chips
          var allowed = {'growing_cystic':1, 'becomes_multiloc':1, 'growing_wall_or_nodularity':1};
          var detBtns2 = details.querySelectorAll('.chip');
          for (var j2=0;j2<detBtns2.length;j2++){
            var dv2 = detBtns2[j2].getAttribute('data-val');
            detBtns2[j2].style.display = allowed[dv2] ? '' : 'none';
          }
          
          // Reorder details chips to: growing_cystic, becomes_multiloc, growing_wall_or_nodularity
          try {
            var desired = ['growing_cystic','becomes_multiloc','growing_wall_or_nodularity'];
            desired.forEach(function(key){
              var btn = details.querySelector('.chip[data-val="'+key+'"]');
              if (btn) details.appendChild(btn);
            });
          } catch(_r) {}
// If status is not progression, de-activate any active detail chip (details are only for progression)
          if (s !== 'progression'){
            var act = details.querySelectorAll('.chip.active');
            for (var a=0;a<act.length;a++){ act[a].classList.remove('active'); }
          }
        }
      } else {
        // Leaving thick mode: remove any cloned growing_cystic detail chip
        if (typeof details !== 'undefined' && details){
          var clones = details.querySelectorAll('.chip[data-val="growing_cystic"][data-cloned="1"]');
          for (var c=0;c<clones.length;c++){ clones[c].remove(); }
        }
      }
    } catch(__e) {}

        if (m==='thin'){
          var bm = details.querySelector('.chip[data-val="becomes_multiloc"]');
          if (bm && !bm.classList.contains('active')) {
            // clear actives then set this one
            var all = details.querySelectorAll('.chip.active');
            for (var k=0;k<all.length;k++){ all[k].classList.remove('active'); }
            bm.classList.add('active');
          }
        }
      }
    } catch(_e) {}

    if (s==='growing_cystic'){
      // Thick-walled + 'Growing cystic component' should be 4A; otherwise default 3
      hidden.value = (m==='thick') ? '4a_thick_or_multiloc' : '3_growing_cystic';
      detailsWrap.style.display = 'none';
    }else if(s==='progression'){
      detailsWrap.style.display = 'block';
      // Determine if special 4A applies: becomes_multiloc with thin or thick morphology
      var dwrap = byId('cyst_progchips'), special4A = false;
      if(dwrap){
        var active = [];
        var chips = dwrap.querySelectorAll('.chip.active');
        for (var i=0;i<chips.length;i++){
          active.push(chips[i].getAttribute('data-val'));
        }
        if (active.indexOf('becomes_multiloc') !== -1 && (m==='thin' || m==='thick')){
          special4A = true;
        }
      }
      hidden.value = special4A ? '4a_thick_or_multiloc' : '4b_progression';
    }else{ // baseline
      detailsWrap.style.display = 'none';
      if(m==='thick' || m==='multiloc'){
        hidden.value = '4a_thick_or_multiloc';
      }else{
        hidden.value = '2_thin_baseline';
      }
    }
  }

  morph.addEventListener('click', function(e){
    var btn = e.target.closest('.chip');
    if(!btn) return;
    setActive(morph, btn.getAttribute('data-val')); enforceCystUI(); setCystHiddenFromUI(); enforceThickUI();
    recomputeHidden();
  });

  status.addEventListener('click', function(e){
    var btn = e.target.closest('.chip');
    if(!btn) return;
    setActive(status, btn.getAttribute('data-val')); enforceCystUI(); setCystHiddenFromUI(); enforceThickUI();
    recomputeHidden();
  });

  if (details){
    details.addEventListener('click', function(e){ enforceCystUI(); setCystHiddenFromUI(); enforceThickUI();
      var btn = e.target.closest('.chip');
      if(!btn) return;
      toggleDetail(btn);
      recomputeHidden();
    });
  }

  // Initialize defaults
  setActive(morph, morph.dataset.value || 'thin');
  setActive(status, status.dataset.value || 'baseline');
  recomputeHidden();
  enforceThickUI();
  enforceCystUI();
}
function setupFlImmunoRadios(){
  var radios = document.querySelectorAll('input[name="fl_isEligible_radio"]');
  var sel = byId('fl_isEligible');
  if(!radios.length || !sel) return;

  function syncFromRadio(){
    var checked = document.querySelector('input[name="fl_isEligible_radio"]:checked');
    if(!checked) return;
    sel.value = checked.value;
    try{
      var ev = new Event('change', {bubbles:true});
      sel.dispatchEvent(ev);
    }catch(e){
      // Fallback for older Safari
      if (document.createEvent){
        var evt = document.createEvent('HTMLEvents');
        evt.initEvent('change', true, false);
        sel.dispatchEvent(evt);
      }
    }
    try{ if (typeof fl_compute === 'function') { fl_compute(); } }catch(e){}
  }

  radios.forEach(function(r){
    r.addEventListener('change', syncFromRadio);
  });

  // initial sync + compute
  syncFromRadio();
}

function setupFlAgeRiskRadios(){
  function bind(radioName, selectId){
    var radios = document.querySelectorAll('input[name="'+radioName+'"]');
    var sel = byId(selectId);
    if(!radios.length || !sel) return;
    function sync(){
      var checked = document.querySelector('input[name="'+radioName+'"]:checked');
      if(!checked) return;
      sel.value = checked.value;
      try{
        var ev = new Event('change', {bubbles:true});
        sel.dispatchEvent(ev);
      }catch(e){
        if(document.createEvent){
          var evt = document.createEvent('HTMLEvents');
          evt.initEvent('change', true, false);
          sel.dispatchEvent(evt);
        }
      }
      try{ if(typeof fl_compute==='function'){ fl_compute(); } }catch(e){}
    }
    radios.forEach(function(r){ r.addEventListener('change', sync); });
    // initial sync + compute
    sync();
  }
  bind('fl_agegrp_radio','fl_agegrp');
  bind('fl_risk_radio','fl_risk');
}

function setupFlMultiplicityChips(){
  var group = byId('fl_multiplicity_chips');
  var sel = byId('fl_multiplicity');
  if(!group || !sel) return;

  function setActive(val){
    group.dataset.value = val;
    var btns = group.querySelectorAll('.chip');
    for (var i=0;i<btns.length;i++){
      var b = btns[i];
      var on = (b.getAttribute('data-val')===val);
      b.classList.toggle('active', on);
    }
  }

  function sync(val){
    sel.value = val;
    try{
      var ev = new Event('change', {bubbles:true});
      sel.dispatchEvent(ev);
    }catch(e){
      if(document.createEvent){
        var evt = document.createEvent('HTMLEvents');
        evt.initEvent('change', true, false);
        sel.dispatchEvent(evt);
      }
    }
    try{ if (typeof fl_compute==='function'){ fl_compute(); } }catch(e){}
  }

  group.addEventListener('click', function(e){
    var btn = e.target.closest('.chip');
    if(!btn) return;
    var val = btn.getAttribute('data-val');
    setActive(val);
    sync(val);
  });

  // initial activation & sync
  var def = group.getAttribute('data-value') || sel.value || 'single';
  setActive(def);
  sync(def);
}

function setupFlTypeChips(){
  var group = byId('fl_type_chips');
  var sel = byId('fl_type');
  if(!group || !sel) return;

  function setActive(val){
    group.dataset.value = val;
    var btns = group.querySelectorAll('.chip');
    for (var i=0;i<btns.length;i++){
      var b = btns[i];
      var on = (b.getAttribute('data-val')===val);
      b.classList.toggle('active', on);
    }
  }

  function sync(val){
    sel.value = val;
    // trigger change so existing listeners run (updates solid-comp row + compute)
    try{
      var ev = new Event('change', {bubbles:true});
      sel.dispatchEvent(ev);
    }catch(e){
      if(document.createEvent){
        var evt = document.createEvent('HTMLEvents');
        evt.initEvent('change', true, false);
        sel.dispatchEvent(evt);
      }
    }
    try{ if (typeof fl_updateSolidComp==='function'){ fl_updateSolidComp(); } }catch(e){}
    try{ if (typeof fl_compute==='function'){ fl_compute(); } }catch(e){}
  }

  group.addEventListener('click', function(e){
    var btn = e.target.closest('.chip');
    if(!btn) return;
    var val = btn.getAttribute('data-val');
    setActive(val);
    sync(val);
  });

  // Initial activation & sync (honor hidden select if changed elsewhere)
  var def = sel.value || group.getAttribute('data-value') || 'solid';
  setActive(def);
  sync(def);
}

function setupFlSizeChips(){
  var group = byId('fl_sizecat_chips');
  var sel = byId('fl_sizecat');
  if(!group || !sel) return;

  function setActive(val){
    group.dataset.value = val;
    var btns = group.querySelectorAll('.chip');
    for (var i=0;i<btns.length;i++){
      var b = btns[i];
      var on = (b.getAttribute('data-val')===val);
      b.classList.toggle('active', on);
    }
  }

  function sync(val){
    sel.value = val;
    try{
      var ev = new Event('change', {bubbles:true});
      sel.dispatchEvent(ev);
    }catch(e){
      if(document.createEvent){
        var evt = document.createEvent('HTMLEvents');
        evt.initEvent('change', true, false);
        sel.dispatchEvent(evt);
      }
    }
    try{ if (typeof fl_compute==='function'){ fl_compute(); } }catch(e){}
  }

  group.addEventListener('click', function(e){
    var btn = e.target.closest('.chip');
    if(!btn) return;
    var val = btn.getAttribute('data-val');
    setActive(val);
    sync(val);
  });

  // initial activation & sync reflect hidden select's current value
  var def = sel.value || group.getAttribute('data-value') || '6to8';
  setActive(def);
  sync(def);
}

function setupFlSolidCompChips(){
  var group = byId('fl_sccat_chips');
  var sel = byId('fl_sccat');
  if(!group || !sel) return;

  function setActive(val){
    group.dataset.value = val;
    var btns = group.querySelectorAll('.chip');
    for (var i=0;i<btns.length;i++){
      var b = btns[i];
      var on = (b.getAttribute('data-val')===val);
      b.classList.toggle('active', on);
    }
  }

  function sync(val){
    sel.value = val;
    try{
      var ev = new Event('change', {bubbles:true});
      sel.dispatchEvent(ev);
    }catch(e){
      if(document.createEvent){
        var evt = document.createEvent('HTMLEvents');
        evt.initEvent('change', true, false);
        sel.dispatchEvent(evt);
      }
    }
    try{ if (typeof fl_compute==='function'){ fl_compute(); } }catch(e){}
  }

  group.addEventListener('click', function(e){
    var btn = e.target.closest('.chip');
    if(!btn) return;
    var val = btn.getAttribute('data-val');
    setActive(val);
    sync(val);
  });

  // initial activation & sync reflect hidden select's current value
  var def = sel.value || group.getAttribute('data-value') || 'lt6';
  setActive(def);
  sync(def);
}

function setupFlRiskChips(){
  var group = byId('fl_risk_chips');
  var sel = byId('fl_risk');
  if(!group || !sel) return;

  function setActive(val){
    group.dataset.value = val;
    var btns = group.querySelectorAll('.chip');
    for (var i=0;i<btns.length;i++){
      var b = btns[i];
      var on = (b.getAttribute('data-val')===val);
      b.classList.toggle('active', on);
    }
  }

  function sync(val){
    sel.value = val;
    try{
      var ev = new Event('change', {bubbles:true});
      sel.dispatchEvent(ev);
    }catch(e){
      if(document.createEvent){
        var evt = document.createEvent('HTMLEvents');
        evt.initEvent('change', true, false);
        sel.dispatchEvent(evt);
      }
    }
    try{ if (typeof fl_compute==='function'){ fl_compute(); } }catch(e){}
  }

  group.addEventListener('click', function(e){
    var btn = e.target.closest('.chip');
    if(!btn) return;
    var val = btn.getAttribute('data-val');
    setActive(val);
    sync(val);
  });

  // initial activation from hidden select value
  var def = sel.value || group.getAttribute('data-value') || 'low';
  setActive(def);
  sync(def);
}

function init(){
    setupTabs();
    
    
    
    
    
    
    
    
    try{ setupFlRiskChips(); }catch(e){}
try{ setupFlSolidCompChips(); }catch(e){}
try{ setupFlSizeChips(); }catch(e){}
try{ setupFlTypeChips(); }catch(e){}
try{ setupFlMultiplicityChips(); }catch(e){}
try{ setupFlAgeRiskRadios(); }catch(e){}
// Auto-compute on key Fleischner changes (including Age & Risk)
    try{
      var el;
      el = byId('fl_multiplicity'); if(el) el.addEventListener('change', fl_compute);
      el = byId('fl_type'); if(el) el.addEventListener('change', function(){ fl_updateSolidComp(); fl_compute(); });
      el = byId('fl_sizecat'); if(el) el.addEventListener('change', fl_compute);
      el = byId('fl_agegrp'); if(el) el.addEventListener('change', function(){ fl_compute(); });
      el = byId('fl_risk'); if(el) el.addEventListener('change', fl_compute);
    }catch(e){}// Auto-compute on key Fleischner changes
    try{
      byId('fl_multiplicity').addEventListener('change', fl_compute);
      var flt = byId('fl_type');
      if(flt){
        flt.addEventListener('change', function(){ fl_updateSolidComp(); fl_compute(); });
      }
      byId('fl_sizecat').addEventListener('change', fl_compute);
    }catch(e){}
try{ setupFlImmunoRadios(); }catch(e){}
    
    try{ setupCystChips(); }catch(e){}
byId('fl_type').addEventListener('change', fl_updateSolidComp);
    byId('fl_compute').addEventListener('click', fl_compute);
    byId('fl_reset').addEventListener('click', function(){ location.reload(); });
    fl_updateSolidComp();

    byId('lr_compute').addEventListener('click', function(){ safeRun("lr_compute", lr_compute); 
    
    // FINAL OVERRIDE: Thick-walled cyst progression → map details correctly
    try{
      var modeSel = byId('lr_mode');
      if (modeSel && modeSel.value === 'cyst'){
        var morphEl = byId('cyst_morph');
        var statusEl = byId('cyst_status');
        var detailsEl = byId('cyst_progchips');
        if (morphEl && statusEl && detailsEl){
          var m = morphEl.dataset.value || '';
          var s = statusEl.dataset.value || '';
          if (m === 'thick' && s === 'progression'){
            var activeVal = null;
            var chips = detailsEl.querySelectorAll('.chip');
            for (var i=0;i<chips.length;i++){
              if (chips[i].classList.contains('active')){
                activeVal = chips[i].getAttribute('data-val');
                break;
              }
            }
            var out = byId('lr_result');
            if (activeVal === 'growing_cystic'){
              if(out) out.innerHTML = 'Category: 3\rManagement: 6-month LDCT.';
            } else if (activeVal === 'becomes_multiloc'){
              if(out) out.innerHTML = 'Category: 4A\rManagement: 3-month LDCT; PET/CT may be considered if there is a ≥ 8 mm solid nodule or solid component.';
            } else if (activeVal === 'growing_wall_or_nodularity'){
              if(out) out.innerHTML = 'Category: 4B\rManagement: Referral for further clinical evaluation. Diagnostic chest CT (± IV contrast); PET/CT may be considered if there is a ≥ 8 mm solid nodule or solid component; tissue sampling and/or surgical evaluation as appropriate.';
            }
          }
        }
      }
    }catch(_e){} 
});
    byId('lr_reset').addEventListener('click', function(){ location.reload(); });
    byId('lr_mode').addEventListener('change', showMode);
    byId('lr_diag_btn').addEventListener('click', lr_diag);
    showMode();
    try{ setTimeout(togglePartSolidSC, 0); }catch(e){}
    var _bp=document.getElementById('lr_behavior_part'); if(_bp){ _bp.addEventListener('change', togglePartSolidSC); }
    var _sp=document.getElementById('lr_size_part_cat'); if(_sp){ _sp.addEventListener('change', togglePartSolidSC); }
    togglePartSolidSC();
    ensurePartListeners();
    setTimeout(togglePartSolidSC, 0);

    buildQA();
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
})();
</script>

<script>
document.addEventListener('DOMContentLoaded', function(){
  var target = document.getElementById('lr_result');
  if (!target) return;

  function stripReasons(){
    var t = target.textContent || '';
    if (t.indexOf('Reasons:') === -1) return;
    var lines = t.split('\n');
    var out = [];
    for (var i=0; i<lines.length; i++){
      var L = lines[i];
      if (L.trim().startsWith('Reasons:')){
        // skip "Reasons:" and subsequent bullet lines until the next header (e.g., "Management:")
        i++;
        while (i < lines.length){
          var s = lines[i].trim();
          if (s.startsWith('- ')) { i++; continue; }
          if (s.length === 0) { i++; continue; }
          // stop skipping once we reach the next non-bullet line
          break;
        }
        // fall through to push the current non-bullet line at this index on next loop iteration
      }
      if (i < lines.length) out.push(lines[i]);
    }
    target.textContent = out.join('\n');
  }

  // Run once and whenever the result node changes
  var obs = new MutationObserver(function(){ stripReasons(); });
  obs.observe(target, { characterData: true, childList: true, subtree: true });
  stripReasons();
});
</script>


<script>
document.addEventListener('DOMContentLoaded', function() {
  var sel = document.getElementById('lr_mode');
  var hdr = document.getElementById('lr_find_heading');
  if (!sel || !hdr) return;
  function updateHdr() {
    var txt = sel.options[sel.selectedIndex] ? sel.options[sel.selectedIndex].text.trim() : '';
    hdr.textContent = txt || 'Finding type';
  }
  sel.addEventListener('change', updateHdr);
  updateHdr();
});
</script>


<script>
document.addEventListener('DOMContentLoaded', function(){
  function dispatchChange(el){
    try{
      var ev = new Event('change', {bubbles:true});
      el.dispatchEvent(ev);
    }catch(e){
      if(document.createEvent){
        var evt = document.createEvent('HTMLEvents');
        evt.initEvent('change', true, false);
        el.dispatchEvent(evt);
      }
    }
  }
  (function initSolidSizeChips(){
    var group = document.getElementById('lr_size_solid_chips');
    if(!group) return;
    var sel = document.getElementById(group.getAttribute('data-select'));
    if(!sel) return;
    var btns = group.querySelectorAll('.chip');
    function setActive(val){
      group.dataset.value = val || '';
      for (var i=0;i<btns.length;i++){
        var b = btns[i];
        b.classList.toggle('active', b.getAttribute('data-val')===val);
      }
    }
    function syncToSelect(val){
      if (sel.value !== val){
        sel.value = val;
      }
      dispatchChange(sel);
    }
    group.addEventListener('click', function(e){
      var btn = e.target.closest('.chip');
      if(!btn) return;
      var val = btn.getAttribute('data-val');
      setActive(val);
      syncToSelect(val);
    });
    // initialize from select's current value
    var initial = sel.value || (sel.options[sel.selectedIndex] ? sel.options[sel.selectedIndex].value : '');
    if(!initial && btns.length){ initial = btns[0].getAttribute('data-val'); }
    setActive(initial);
    syncToSelect(initial);
  })();
});
</script>


<script>
document.addEventListener('DOMContentLoaded', function(){
  function dispatchChange(el){
    try{
      var ev = new Event('change', {bubbles:true});
      el.dispatchEvent(ev);
    }catch(e){
      if(document.createEvent){
        var evt = document.createEvent('HTMLEvents');
        evt.initEvent('change', true, false);
        el.dispatchEvent(evt);
      }
    }
  }
  (function initNSSizeChips(){
    var group = document.getElementById('lr_size_ns_chips');
    if(!group) return;
    var sel = document.getElementById(group.getAttribute('data-select'));
    if(!sel) return;
    var btns = group.querySelectorAll('.chip');
    function setActive(val){
      group.dataset.value = val || '';
      for (var i=0;i<btns.length;i++){
        var b = btns[i];
        b.classList.toggle('active', b.getAttribute('data-val')===val);
      }
    }
    function syncToSelect(val){
      if (sel.value !== val){
        sel.value = val;
      }
      dispatchChange(sel);
    }
    group.addEventListener('click', function(e){
      var btn = e.target.closest('.chip');
      if(!btn) return;
      var val = btn.getAttribute('data-val');
      setActive(val);
      syncToSelect(val);
    });
    // initialize from select's current value
    var initial = sel.value || (sel.options[sel.selectedIndex] ? sel.options[sel.selectedIndex].value : '');
    if(!initial && btns.length){ initial = btns[0].getAttribute('data-val'); }
    setActive(initial);
    syncToSelect(initial);
  })();
});
</script>


<script>
document.addEventListener('DOMContentLoaded', function(){
  function dispatchChange(el){
    try{
      var ev = new Event('change', {bubbles:true});
      el.dispatchEvent(ev);
    }catch(e){
      if(document.createEvent){
        var evt = document.createEvent('HTMLEvents');
        evt.initEvent('change', true, false);
        el.dispatchEvent(evt);
      }
    }
  }
  (function initJPSizeChips(){
    var group = document.getElementById('lr_size_jp_chips');
    if(!group) return;
    var sel = document.getElementById(group.getAttribute('data-select'));
    if(!sel) return;
    var btns = group.querySelectorAll('.chip');
    function setActive(val){
      group.dataset.value = val || '';
      for (var i=0;i<btns.length;i++){
        var b = btns[i];
        b.classList.toggle('active', b.getAttribute('data-val')===val);
      }
    }
    function syncToSelect(val){
      if (sel.value !== val){
        sel.value = val;
      }
      dispatchChange(sel);
    }
    group.addEventListener('click', function(e){
      var btn = e.target.closest('.chip');
      if(!btn) return;
      var val = btn.getAttribute('data-val');
      setActive(val);
      syncToSelect(val);
    });
    // initialize from select's current value
    var initial = sel.value || (sel.options[sel.selectedIndex] ? sel.options[sel.selectedIndex].value : '');
    if(!initial && btns.length){ initial = btns[0].getAttribute('data-val'); }
    setActive(initial);
    syncToSelect(initial);
  })();
});
</script>


<script>
document.addEventListener('DOMContentLoaded', function(){
  function dispatchChange(el){
    try{
      var ev = new Event('change', {bubbles:true});
      el.dispatchEvent(ev);
    }catch(e){
      if(document.createEvent){
        var evt = document.createEvent('HTMLEvents');
        evt.initEvent('change', true, false);
        sel.dispatchEvent(evt);
      }
    }
  }
  (function initPSSizeChips(){
    var group = document.getElementById('lr_size_ps_chips');
    if(!group) return;
    var sel = document.getElementById(group.getAttribute('data-select'));
    if(!sel) return;
    var btns = group.querySelectorAll('.chip');
    function setActive(val){
      group.dataset.value = val || '';
      for (var i=0;i<btns.length;i++){
        var b = btns[i];
        b.classList.toggle('active', b.getAttribute('data-val')===val);
      }
    }
    function syncToSelect(val){
      if (sel.value !== val){
        sel.value = val;
      }
      // always fire downstream logic so show/hide of solid component stays in sync
      try{
        var ev = new Event('change', {bubbles:true});
        sel.dispatchEvent(ev);
      }catch(e){
        if(document.createEvent){
          var evt = document.createEvent('HTMLEvents');
          evt.initEvent('change', true, false);
          sel.dispatchEvent(evt);
        }
      }
    }
    group.addEventListener('click', function(e){
      var btn = e.target.closest('.chip');
      if(!btn) return;
      var val = btn.getAttribute('data-val');
      setActive(val);
      syncToSelect(val);
    });
    // initialize from select's current value
    var initial = sel.value || (sel.options[sel.selectedIndex] ? sel.options[sel.selectedIndex].value : '');
    if(!initial && btns.length){ initial = btns[0].getAttribute('data-val'); }
    setActive(initial);
    syncToSelect(initial);
  })();
});
</script>


<script>
document.addEventListener('DOMContentLoaded', function(){
  function dispatchChange(el){
    try{
      var ev = new Event('change', {bubbles:true});
      el.dispatchEvent(ev);
    }catch(e){
      if(document.createEvent){
        var evt = document.createEvent('HTMLEvents');
        evt.initEvent('change', true, false);
        el.dispatchEvent(evt);
      }
    }
  }
  (function initPartSolidSCChips(){
    var group = document.getElementById('lr_sc_part_chips');
    if(!group) return;
    var selId = group.getAttribute('data-select');
    var sel = document.getElementById(selId);
    if(!sel) return;
    var btns = group.querySelectorAll('.chip');
    function setActive(val){
      group.dataset.value = val || '';
      for (var i=0;i<btns.length;i++){
        var b = btns[i];
        b.classList.toggle('active', b.getAttribute('data-val')===val);
      }
    }
    function syncToSelect(val){
      if (sel.value !== val){
        sel.value = val;
      }
      // Always fire change so downstream logic updates category and any dependent UI
      dispatchChange(sel);
    }
    group.addEventListener('click', function(e){
      var btn = e.target.closest('.chip');
      if(!btn) return;
      var val = btn.getAttribute('data-val');
      setActive(val);
      syncToSelect(val);
    });
    // Initialize from current select value or first chip
    var initial = sel.value || (sel.options[sel.selectedIndex] ? sel.options[sel.selectedIndex].value : '');
    if(!initial && btns.length){ initial = btns[0].getAttribute('data-val'); }
    setActive(initial);
    syncToSelect(initial);
  })();
});
</script>


<script>
document.addEventListener('DOMContentLoaded', function(){
  var prog = document.getElementById('cyst_progchips');
  if(!prog) return;
  prog.addEventListener('click', function(e){
    var btn = e.target.closest('.chip');
    if(!btn) return;
    // clear all actives in this group
    var all = prog.querySelectorAll('.chip');
    for (var i=0;i<all.length;i++){ all[i].classList.remove('active'); }
    // activate the clicked one
    btn.classList.add('active');
    // If downstream logic reads selected states, trigger a change on a synthetic hidden input if present
    // (No-op here; existing compute likely checks .active on chips)
  });
});
</script>


<script>
document.addEventListener('DOMContentLoaded', function(){
  function dispatchChange(el){
    try{
      var ev = new Event('change', {bubbles:true});
      el.dispatchEvent(ev);
    }catch(e){
      if(document.createEvent){
        var evt = document.createEvent('HTMLEvents');
        evt.initEvent('change', true, false);
        el.dispatchEvent(evt);
      }
    }
  }
  (function initAirwayLocChips(){
    var group = document.getElementById('airway_loc_chips');
    if(!group) return;
    var sel = document.getElementById(group.getAttribute('data-select'));
    if(!sel) return;
    var btns = group.querySelectorAll('.chip');
    function setActive(val){
      group.dataset.value = val || '';
      for (var i=0;i<btns.length;i++){
        var b = btns[i];
        b.classList.toggle('active', b.getAttribute('data-val')===val);
      }
    }
    function syncToSelect(val){
      if (sel.value !== val){ sel.value = val; }
      dispatchChange(sel);
    }
    group.addEventListener('click', function(e){
      var btn = e.target.closest('.chip');
      if(!btn) return;
      var val = btn.getAttribute('data-val');
      setActive(val);
      syncToSelect(val);
    });
    // initialize from select's current value or first option
    var initial = sel.value || (sel.options[sel.selectedIndex] ? sel.options[sel.selectedIndex].value : '');
    if(!initial && btns.length){ initial = btns[0].getAttribute('data-val'); }
    setActive(initial);
    syncToSelect(initial);
  })();
});
</script>


<script>
document.addEventListener('DOMContentLoaded', function(){
  function dispatchChange(el){
    try{
      var ev = new Event('change', {bubbles:true});
      el.dispatchEvent(ev);
    }catch(e){
      if(document.createEvent){
        var evt = document.createEvent('HTMLEvents');
        evt.initEvent('change', true, false);
        el.dispatchEvent(evt);
      }
    }
  }
  (function initJuxtaBehaviorChips(){
    var group = document.getElementById('lr_behavior_juxta_chips');
    if(!group) return;
    var sel = document.getElementById(group.getAttribute('data-select'));
    if(!sel) return;
    var btns = group.querySelectorAll('.chip');
    function setActive(val){
      group.dataset.value = val || '';
      for (var i=0;i<btns.length;i++){
        var b = btns[i];
        b.classList.toggle('active', b.getAttribute('data-val')===val);
      }
    }
    function syncToSelect(val){
      if (sel.value !== val){
        sel.value = val;
      }
      dispatchChange(sel);
    }
    group.addEventListener('click', function(e){
      var btn = e.target.closest('.chip');
      if(!btn) return;
      var val = btn.getAttribute('data-val');
      setActive(val);
      syncToSelect(val);
    });
    // initialize from select's current value or first option
    var initial = sel.value || (sel.options[sel.selectedIndex] ? sel.options[sel.selectedIndex].value : '');
    if(!initial && btns.length){ initial = btns[0].getAttribute('data-val'); }
    setActive(initial);
    syncToSelect(initial);
  })();
});
</script>


<script>
document.addEventListener('DOMContentLoaded', function(){
  function dispatchChange(el){
    try{
      var ev = new Event('change', {bubbles:true});
      el.dispatchEvent(ev);
    }catch(e){
      if(document.createEvent){
        var evt = document.createEvent('HTMLEvents');
        evt.initEvent('change', true, false);
        el.dispatchEvent(evt);
      }
    }
  }
  (function initNSBehaviorChips(){
    var group = document.getElementById('lr_behavior_ns_chips');
    if(!group) return;
    var sel = document.getElementById(group.getAttribute('data-select'));
    if(!sel) return;
    var btns = group.querySelectorAll('.chip');
    function setActive(val){
      group.dataset.value = val || '';
      for (var i=0;i<btns.length;i++){
        var b = btns[i];
        b.classList.toggle('active', b.getAttribute('data-val')===val);
      }
    }
    function syncToSelect(val){
      if (sel.value !== val){
        sel.value = val;
      }
      dispatchChange(sel);
    }
    group.addEventListener('click', function(e){
      var btn = e.target.closest('.chip');
      if(!btn) return;
      var val = btn.getAttribute('data-val');
      setActive(val);
      syncToSelect(val);
    });
    // initialize from select's current value or first option
    var initial = sel.value || (sel.options[sel.selectedIndex] ? sel.options[sel.selectedIndex].value : '');
    if(!initial && btns.length){ initial = btns[0].getAttribute('data-val'); }
    setActive(initial);
    syncToSelect(initial);
  })();
});
</script>


<script>
document.addEventListener('DOMContentLoaded', function(){
  function dispatchChange(el){
    try{ el.dispatchEvent(new Event('change', {bubbles:true})); }
    catch(e){
      if(document.createEvent){ var evt=document.createEvent('HTMLEvents'); evt.initEvent('change', true, false); el.dispatchEvent(evt); }
    }
  }
  (function initPSBehaviorChips(){
    var group = document.getElementById('lr_behavior_part_chips');
    if(!group) return;
    var sel = document.getElementById(group.getAttribute('data-select'));
    if(!sel) return;
    var btns = group.querySelectorAll('.chip');
    function setActive(val){
      group.dataset.value = val || '';
      for (var i=0;i<btns.length;i++){
        var b = btns[i];
        b.classList.toggle('active', b.getAttribute('data-val')===val);
      }
    }
    function syncToSelect(val){
      if (sel.value !== val){ sel.value = val; }
      dispatchChange(sel);
      // Ensure the Part-solid SC visibility logic is refreshed
      if (typeof togglePartSolidSC === 'function'){ try{ togglePartSolidSC(); }catch(_e){} }
    }
    group.addEventListener('click', function(e){
      var btn = e.target.closest('.chip');
      if(!btn) return;
      var val = btn.getAttribute('data-val');
      setActive(val);
      syncToSelect(val);
    });
    // Initialize
    var initial = sel.value || (sel.options[sel.selectedIndex] ? sel.options[sel.selectedIndex].value : '');
    if(!initial && btns.length){ initial = btns[0].getAttribute('data-val'); }
    setActive(initial);
    syncToSelect(initial);
  })();
});
</script>


<script>
document.addEventListener('DOMContentLoaded', function(){
  function dispatchChange(el){
    try{ el.dispatchEvent(new Event('change', {bubbles:true})); }
    catch(e){
      if(document.createEvent){ var evt=document.createEvent('HTMLEvents'); evt.initEvent('change', true, false); el.dispatchEvent(evt); }
    }
  }
  (function initSolidBehaviorChips(){
    var group = document.getElementById('lr_behavior_solid_chips');
    if(!group) return;
    var sel = document.getElementById(group.getAttribute('data-select'));
    if(!sel) return;
    var btns = group.querySelectorAll('.chip');
    function setActive(val){
      group.dataset.value = val || '';
      for (var i=0;i<btns.length;i++){
        var b = btns[i];
        b.classList.toggle('active', b.getAttribute('data-val')===val);
      }
    }
    function syncToSelect(val){
      if (sel.value !== val){ sel.value = val; }
      dispatchChange(sel);
    }
    group.addEventListener('click', function(e){
      var btn = e.target.closest('.chip');
      if(!btn) return;
      var val = btn.getAttribute('data-val');
      setActive(val);
      syncToSelect(val);
    });
    // Initialize from select value or first option
    var initial = sel.value || (sel.options[sel.selectedIndex] ? sel.options[sel.selectedIndex].value : '');
    if(!initial && btns.length){ initial = btns[0].getAttribute('data-val'); }
    setActive(initial);
    syncToSelect(initial);
  })();
});
</script>


<script>
(function(){
  if (!window._origSetLrResult) {
    window._origSetLrResult = window.setLrResult;
    window.setLrResult = function(cat){
      try{
        var modeEl = document.getElementById('lr_mode');
        var mode = modeEl ? modeEl.value : 'solid';
        if (mode === 'solid') {
          var behEl = document.getElementById('lr_behavior_solid');
          var sizeEl = document.getElementById('lr_size_solid_cat');
          var beh = behEl ? behEl.value : 'baseline';
          var size = sizeEl ? sizeEl.value : '';
          var ge8 = (size === '8to9_9' || size === '10to14_9' || size === '15to29_9' || size === 'ge30');
          if (String(cat).toUpperCase() !== '4X') {
            if (beh === 'growing') {
              cat = ge8 ? '4B' : '4A';
            } else if (beh === 'slow_multi') {
              cat = '4B';
            }
          }
        }
      }catch(e){ /* no-op */ }
      return window._origSetLrResult(cat);
    };
  }
})();
</script>


<script>
(function(){
  // Post-compute correction for Atypical pulmonary cyst (Thick-walled) mappings
  function correctCystCategory(){
    try{
      var mode = document.getElementById('lr_mode');
      if(!mode || mode.value !== 'cyst') return;
      var morph = document.getElementById('cyst_morph');
      var status = document.getElementById('cyst_status');
      var details = document.getElementById('cyst_progchips');
      if(!morph || !status || !details) return;
      var m = morph.dataset.value, s = status.dataset.value;
      var det = (function(){
        var a = details.querySelector('.chip.active');
        return a ? a.getAttribute('data-val') : null;
      })();
      var fixCat = null, fixMgmt = null;
      if(m === 'thick' && s === 'progression'){
        if(det === 'growing_cystic'){
          fixCat = '3';
          fixMgmt = '6-month LDCT.';
        } else if(det === 'growing_wall_or_nodularity'){
          fixCat = '4B';
          fixMgmt = 'Diagnostic chest CT ± contrast; consider PET/CT and/or tissue sampling.';
        }
      }
      if(fixCat){
        var out = document.getElementById('lr_result');
        if(out){
          // Keep consistent format: single-line category and management
          out.innerHTML = 'Category: ' + fixCat + '  —  Management: ' + (fixMgmt || '');
        }
      }
    }catch(e){/* no-op */}
  }

  // Wire correction after compute clicks and user interactions
//  var btn = document.getElementById('lr_compute');
//  if(btn){
//    btn.addEventListener('click', function(){ setTimeout(correctCystCategory, 0); setTimeout(correctCystCategory, 120); }, true);
//  }
  // Also run on general interactions inside Lung-RADS to keep in sync
//  var root = document.getElementById('lungrads');
//  if(root){
//    ['change','click'].forEach(function(ev){
//      root.addEventListener(ev, function(){ setTimeout(correctCystCategory, 120); }, true);
//    });
  }
})();
</script>

<script>
/* --- OVERRIDE 2: Strict option set for Thick-walled cyst --- */
try {
  var morph = document.getElementById('cyst_morph');
  var status = document.getElementById('cyst_status');
  var statusChips = document.getElementById('cyst_statuschips') || status;
  var details = document.getElementById('cyst_progchips');

  if (morph && status && details) {
    var m = morph.dataset ? morph.dataset.value : null;
    var s = status.dataset ? status.dataset.value : null;

    if (m === 'thick') {
      // Show only Baseline and Progression in Status
      var keepStatus = { 'baseline':1, 'progression':1 };
      var stBtns = (statusChips || status).querySelectorAll('.chip');
      for (var i=0;i<stBtns.length;i++) {
        var v = stBtns[i].getAttribute('data-val');
        stBtns[i].style.display = keepStatus[v] ? '' : 'none';
      }
      if (!keepStatus[s]) {
        if (statusChips && typeof setActive === 'function') setActive(statusChips, 'baseline');
        else if (typeof setActive === 'function') setActive(status, 'baseline');
        status.dataset.value = 'baseline';
        s = 'baseline';
      }

      // Show only 3 detail options
      var keepDetails = { 'growing_cystic':1, 'becomes_multiloc':1, 'growing_wall_or_nodularity':1 };
      var detBtns = details.querySelectorAll('.chip');
      for (var j=0;j<detBtns.length;j++) {
        var dv = detBtns[j].getAttribute('data-val');
        detBtns[j].style.display = keepDetails[dv] ? '' : 'none';
      }
      // If status is not progression, de-activate any selected detail (details are only meaningful for progression)
      if (s !== 'progression') {
        var act = details.querySelectorAll('.chip.active');
        for (var a=0;a<act.length;a++) act[a].classList.remove('active');
      }
    } else {
      // Leaving thick: unhide any previously hidden chips
      var allSt = (statusChips || status).querySelectorAll('.chip');
      for (var i2=0;i2<allSt.length;i2++) allSt[i2].style.display = '';
      var allDet = details.querySelectorAll('.chip');
      for (var j2=0;j2<allDet.length;j2++) allDet[j2].style.display = '';
    }
  }
} catch(__e) { /* no-op */ }
/* --- END OVERRIDE 2 --- */
</script>

<script>
(function(){
  function byId(id){ return document.getElementById(id); }
  function ensureThickDefault(morph){
    try{
      if (!morph) return;
      var cur = (morph.dataset && morph.dataset.value) ? morph.dataset.value : '';
      if (cur !== 'thick'){
        var thickBtn = morph.querySelector('.chip[data-val="thick"]');
        if (thickBtn){
          if (typeof setActive === 'function'){ setActive(morph, 'thick'); }
          else {
            // Fallback: toggle classes/dataset
            var chips = morph.querySelectorAll('.chip');
            for (var i=0;i<chips.length;i++){ chips[i].classList.remove('active'); }
            thickBtn.classList.add('active');
            morph.dataset.value = 'thick';
          }
        }
      }
    }catch(e){ /* swallow */ }
  }

  function enforceMultilocHides(morph, status, details){
    try{
      if (!morph || !status || !details) return;
      var m = (morph.dataset && morph.dataset.value) ? morph.dataset.value : '';
      var s = (status.dataset && status.dataset.value) ? status.dataset.value : '';
      var hideThick = ['growing_cystic','becomes_multiloc','growing_wall_or_nodularity'];

      if (m === 'multiloc' && s === 'progression'){
        hideThick.forEach(function(val){
          var el = details.querySelector('.chip[data-val="'+val+'"]');
          if (el){
            el.style.display = 'none';
            if (el.classList.contains('active')) el.classList.remove('active');
          }
        });
      } else {
        // restore visibility when not multiloc+progression
        hideThick.forEach(function(val){
          var el = details.querySelector('.chip[data-val="'+val+'"]');
          if (el){ el.style.display = ''; }
        });
      }
    }catch(e){ /* swallow */ }
  }

  document.addEventListener('DOMContentLoaded', function(){
    try{
      var morph = byId('cyst_morph');
      var status = byId('cyst_status');
      var details = byId('cyst_progchips');
      if (!morph || !status || !details) return;

      // 1) Default to Thick-walled
      ensureThickDefault(morph);

      // 2) Enforce hides dynamically
      var handler = function(ev){
        enforceMultilocHides(morph, status, details);
      };
      morph.addEventListener('click', handler, true);
      status.addEventListener('click', handler, true);
      details.addEventListener('click', handler, true);

      // Initial enforce
      enforceMultilocHides(morph, status, details);
    }catch(e){ /* swallow */ }
  });
})();
</script>


<script>
// ---- Multilocular cyst progression filter (requested patch) ----
(function(){
  function $id(x){ return document.getElementById(x); }
  function updateCystProgChips(){
    var morphEl = $id('cyst_morph');
    var statusEl = $id('cyst_status');
    var detailsWrap = $id('cyst_prog_details');
    var details = $id('cyst_progchips');
    if(!details) return;
    // Default: show all chips
    var chips = details.querySelectorAll('.chip');
    chips.forEach(function(ch){ ch.style.display = ''; });
    // Show progression details only when Status = progression
    if(detailsWrap && statusEl){
      var status = (statusEl.dataset && statusEl.dataset.value) || statusEl.getAttribute('data-value') || '';
      detailsWrap.style.display = (status === 'progression') ? 'block' : 'none';
    }
    // If Multilocular + Progression -> only 3 chips
    if(morphEl && statusEl){
      var morph = (morphEl.dataset && morphEl.dataset.value) || morphEl.getAttribute('data-value') || '';
      var status = (statusEl.dataset && statusEl.dataset.value) || statusEl.getAttribute('data-value') || '';
      if(morph === 'multiloc' && status === 'progression'){
        var allowed = new Set(['growing_multiloc','increased_loculation','new_or_increased_opacity']);
        chips.forEach(function(ch){
          var val = ch.getAttribute('data-val');
          if(!allowed.has(val)) ch.style.display = 'none';
        });
      }
    }
  }

  function wireChipGroup(id){
    var grp = $id(id);
    if(!grp) return;
    grp.addEventListener('click', function(e){
      var btn = e.target.closest('.chip');
      if(!btn) return;
      var val = btn.getAttribute('data-val');
      // toggle active class
      grp.querySelectorAll('.chip').forEach(function(c){ c.classList.remove('active'); });
      btn.classList.add('active');
      // store value on dataset for our logic
      grp.dataset.value = val;
      updateCystProgChips();
    });
  }

  document.addEventListener('DOMContentLoaded', function(){
    try{
      wireChipGroup('cyst_morph');
      wireChipGroup('cyst_status');
      // Fallback: also observe any change to hidden select if present
      ['lr_cyst_mode'].forEach(function(id){
        var el = $id(id);
        if(el){ el.addEventListener('change', updateCystProgChips); }
      });
      updateCystProgChips();
    }catch(_e){ /* no-op */ }
  });
})();
</script>

<script>
// ---- Thin-walled cyst restriction (requested patch 2) ----
(function(){
  function $id(x){ return document.getElementById(x); }
  function updateThinCystUI(){
    var morphEl = $id('cyst_morph');
    var statusGrp = $id('cyst_status');
    var details = $id('cyst_progchips');
    if(!morphEl || !statusGrp || !details) return;
    var morph = (morphEl.dataset && morphEl.dataset.value) || morphEl.getAttribute('data-value') || '';
    var chips = statusGrp.querySelectorAll('.chip');
    var detchips = details.querySelectorAll('.chip');
    // Reset all displays
    chips.forEach(ch => ch.style.display = '');
    detchips.forEach(ch => ch.style.display = '');
    if(morph === 'thin'){
      // Only Progression visible
      chips.forEach(ch => {
        var v = ch.getAttribute('data-val');
        if(v !== 'progression') ch.style.display = 'none';
        else {
          // auto-select Progression
          chips.forEach(c => c.classList.remove('active'));
          ch.classList.add('active');
          statusGrp.dataset.value = 'progression';
        }
      });
      // Only Growing cystic component visible
      detchips.forEach(ch => {
        if(ch.getAttribute('data-val') !== 'growing_cystic') ch.style.display = 'none';
      });
      var detwrap = $id('cyst_prog_details');
      if(detwrap) detwrap.style.display = 'block';
    }
  }
  document.addEventListener('DOMContentLoaded', function(){
    ['cyst_morph','cyst_status'].forEach(id=>{
      var el=$id(id);
      if(el){
        el.addEventListener('click',updateThinCystUI);
      }
    });
    updateThinCystUI();
  });
})();
</script>

<script>
// ---- Thin-walled cyst restriction (updated patch 3) ----
(function(){
  function $id(x){ return document.getElementById(x); }
  function updateThinCystUI(){
    var morphEl = $id('cyst_morph');
    var statusGrp = $id('cyst_status');
    var details = $id('cyst_progchips');
    if(!morphEl || !statusGrp || !details) return;
    var morph = (morphEl.dataset && morphEl.dataset.value) || morphEl.getAttribute('data-value') || '';
    var chips = statusGrp.querySelectorAll('.chip');
    var detchips = details.querySelectorAll('.chip');
    // Reset all displays
    chips.forEach(ch => ch.style.display = '');
    detchips.forEach(ch => ch.style.display = '');
    if(morph === 'thin'){
      // Only Progression visible
      chips.forEach(ch => {
        var v = ch.getAttribute('data-val');
        if(v !== 'progression') ch.style.display = 'none';
        else {
          // auto-select Progression
          chips.forEach(c => c.classList.remove('active'));
          ch.classList.add('active');
          statusGrp.dataset.value = 'progression';
        }
      });
      // Only Becomes multilocular visible
      detchips.forEach(ch => {
        if(ch.getAttribute('data-val') !== 'becomes_multiloc') ch.style.display = 'none';
      });
      var detwrap = $id('cyst_prog_details');
      if(detwrap) detwrap.style.display = 'block';
    }
  }
  document.addEventListener('DOMContentLoaded', function(){
    ['cyst_morph','cyst_status'].forEach(id=>{
      var el=$id(id);
      if(el){
        el.addEventListener('click',updateThinCystUI);
      }
    });
    updateThinCystUI();
  });
})();
</script>

<script>
// ---- Unified cyst logic patch (v21) ----
(function(){
  function $id(x){ return document.getElementById(x); }
  function updateCystUI(){
    var morphEl = $id('cyst_morph');
    var statusGrp = $id('cyst_status');
    var details = $id('cyst_progchips');
    var detwrap = $id('cyst_prog_details');
    if(!morphEl || !statusGrp || !details) return;

    var morph = (morphEl.dataset && morphEl.dataset.value) || morphEl.getAttribute('data-value') || '';
    var status = (statusGrp.dataset && statusGrp.dataset.value) || statusGrp.getAttribute('data-value') || '';
    var chips = statusGrp.querySelectorAll('.chip');
    var detchips = details.querySelectorAll('.chip');
    chips.forEach(ch => ch.style.display = '');
    detchips.forEach(ch => ch.style.display = '');

    // Default: show all progression chips only if Status=progression
    if(detwrap) detwrap.style.display = (status === 'progression') ? 'block' : 'none';

    // --- Thin-walled ---
    if(morph === 'thin'){
      // Only Progression visible and auto-selected
      chips.forEach(ch => {
        var v = ch.getAttribute('data-val');
        if(v !== 'progression') ch.style.display = 'none';
        else {
          chips.forEach(c => c.classList.remove('active'));
          ch.classList.add('active');
          statusGrp.dataset.value = 'progression';
          status = 'progression';
        }
      });
      // Only Becomes multilocular
      detchips.forEach(ch => {
        if(ch.getAttribute('data-val') !== 'becomes_multiloc') ch.style.display = 'none';
      });
      if(detwrap) detwrap.style.display = 'block';
    }

    // --- Multilocular ---
    if(morph === 'multiloc' && status === 'progression'){
      var allowed = new Set(['growing_multiloc','increased_loculation','new_or_increased_opacity']);
      detchips.forEach(ch => {
        var val = ch.getAttribute('data-val');
        if(!allowed.has(val)) ch.style.display = 'none';
      });
    }

    // --- Thick-walled ---
    if(morph === 'thick' && status === 'progression'){
      var allowed2 = new Set(['growing_cystic','becomes_multiloc','growing_wall_or_nodularity']);
      detchips.forEach(ch => {
        var val = ch.getAttribute('data-val');
        if(!allowed2.has(val)) ch.style.display = 'none';
      });
    }
  }

  function wireChipGroup(id){
    var grp = $id(id);
    if(!grp) return;
    grp.addEventListener('click', function(e){
      var btn = e.target.closest('.chip');
      if(!btn) return;
      var val = btn.getAttribute('data-val');
      grp.querySelectorAll('.chip').forEach(c=>c.classList.remove('active'));
      btn.classList.add('active');
      grp.dataset.value = val;
      updateCystUI();
    });
  }

  document.addEventListener('DOMContentLoaded', function(){
    wireChipGroup('cyst_morph');
    wireChipGroup('cyst_status');
    updateCystUI();
  });
})();
</script>

<script>
// ---- v22 cyst chip fix: prevent reset when clicking inside details ----
(function(){
  function $id(x){ return document.getElementById(x); }
  function updateCystUI(){
    var morphEl = $id('cyst_morph');
    var statusGrp = $id('cyst_status');
    var details = $id('cyst_progchips');
    var detwrap = $id('cyst_prog_details');
    if(!morphEl || !statusGrp || !details) return;

    var morph = (morphEl.dataset && morphEl.dataset.value) || morphEl.getAttribute('data-value') || '';
    var status = (statusGrp.dataset && statusGrp.dataset.value) || statusGrp.getAttribute('data-value') || '';
    var chips = statusGrp.querySelectorAll('.chip');
    var detchips = details.querySelectorAll('.chip');

    // Always start with all hidden, then selectively unhide
    chips.forEach(ch => ch.style.display = '');
    detchips.forEach(ch => ch.style.display = 'none');

    // Default visibility for progression details block
    if(detwrap) detwrap.style.display = (status === 'progression') ? 'block' : 'none';

    // --- Thin-walled ---
    if(morph === 'thin'){
      chips.forEach(ch => {
        var v = ch.getAttribute('data-val');
        if(v !== 'progression') ch.style.display = 'none';
        else {
          chips.forEach(c => c.classList.remove('active'));
          ch.classList.add('active');
          statusGrp.dataset.value = 'progression';
          status = 'progression';
        }
      });
      detchips.forEach(ch => {
        if(ch.getAttribute('data-val') === 'becomes_multiloc') ch.style.display = '';
      });
      if(detwrap) detwrap.style.display = 'block';
    }

    // --- Multilocular ---
    if(morph === 'multiloc' && status === 'progression'){
      var allowed = new Set(['growing_multiloc','increased_loculation','new_or_increased_opacity']);
      detchips.forEach(ch => {
        if(allowed.has(ch.getAttribute('data-val'))) ch.style.display = '';
      });
    }

    // --- Thick-walled ---
    if(morph === 'thick' && status === 'progression'){
      var allowed2 = new Set(['growing_cystic','becomes_multiloc','growing_wall_or_nodularity']);
      detchips.forEach(ch => {
        if(allowed2.has(ch.getAttribute('data-val'))) ch.style.display = '';
      });
    }
  }

  function wireChipGroup(id){
    var grp = $id(id);
    if(!grp) return;
    grp.addEventListener('click', function(e){
      // Prevent clicks inside details from triggering full reset
      if (e.target.closest('#cyst_progchips')) return;
      var btn = e.target.closest('.chip');
      if(!btn) return;
      var val = btn.getAttribute('data-val');
      grp.querySelectorAll('.chip').forEach(c=>c.classList.remove('active'));
      btn.classList.add('active');
      grp.dataset.value = val;
      updateCystUI();
    });
  }

  document.addEventListener('DOMContentLoaded', function(){
    wireChipGroup('cyst_morph');
    wireChipGroup('cyst_status');
    updateCystUI();
  });
})();
</script>

<script>
// ---- v23: Full cyst logic isolation and persistent filtering ----
(function(){
  function $id(x){ return document.getElementById(x); }
  function updateCystUI(){
    var morphEl = $id('cyst_morph');
    var statusGrp = $id('cyst_status');
    var details = $id('cyst_progchips');
    var detwrap = $id('cyst_prog_details');
    if(!morphEl || !statusGrp || !details) return;

    var morph = morphEl.dataset?.value || morphEl.getAttribute('data-value') || '';
    var status = statusGrp.dataset?.value || statusGrp.getAttribute('data-value') || '';

    // Determine allowed progression chips
    var allowed = null;
    if(morph === 'thin'){
      // Only Progression, auto-selected
      status = 'progression';
      statusGrp.dataset.value = 'progression';
      allowed = new Set(['becomes_multiloc']);
    } else if(morph === 'multiloc' && status === 'progression'){
      allowed = new Set(['growing_multiloc','increased_loculation','new_or_increased_opacity']);
    } else if(morph === 'thick' && status === 'progression'){
      allowed = new Set(['growing_cystic','becomes_multiloc','growing_wall_or_nodularity']);
    }

    // --- Handle visibility of status buttons ---
    var statusBtns = statusGrp.querySelectorAll('.chip');
    statusBtns.forEach(btn => {
      if(morph === 'thin'){
        // only Progression visible
        btn.style.display = (btn.getAttribute('data-val') === 'progression') ? '' : 'none';
        if(btn.getAttribute('data-val') === 'progression'){
          statusBtns.forEach(c=>c.classList.remove('active'));
          btn.classList.add('active');
        }
      } else {
        btn.style.display = '';
      }
    });

    // --- Handle visibility of progression detail chips ---
    var detchips = details.querySelectorAll('.chip');
    detchips.forEach(ch => {
      if(!allowed) {
        // default: show all if not restricted
        ch.style.display = '';
      } else {
        ch.style.display = allowed.has(ch.getAttribute('data-val')) ? '' : 'none';
      }
    });

    // Show or hide progression section
    if(detwrap){
      detwrap.style.display = (status === 'progression') ? 'block' : 'none';
    }
  }

  function wireChipGroup(id){
    var grp = $id(id);
    if(!grp) return;
    grp.addEventListener('click', function(e){
      var btn = e.target.closest('.chip');
      if(!btn) return;
      grp.querySelectorAll('.chip').forEach(c=>c.classList.remove('active'));
      btn.classList.add('active');
      grp.dataset.value = btn.getAttribute('data-val');
      updateCystUI();
    });
  }

  document.addEventListener('DOMContentLoaded', function(){
    // Neutralize any previous cyst setup scripts
    if(window.setupCystChips){ window.setupCystChips = function(){}; }
    // Wire our groups
    wireChipGroup('cyst_morph');
    wireChipGroup('cyst_status');
    wireChipGroup('cyst_progchips');
    updateCystUI();
  });
})();
</script>
</body>
</html>